###
00000000   0000000  000000000  000  00     00   0000000   000000000  00000000  
000       000          000     000  000   000  000   000     000     000       
0000000   0000000      000     000  000000000  000000000     000     0000000   
000            000     000     000  000 0 000  000   000     000     000       
00000000  0000000      000     000  000   000  000   000     000     00000000  
###

{ stone } = require './util/util'
{ max, min } = Math
Score = require './score'

function Estimate extends Score

    # 00000000   0000000  000000000  000  00     00   0000000   000000000  00000000  
    # 000       000          000     000  000   000  000   000     000     000       
    # 0000000   0000000      000     000  000000000  000000000     000     0000000   
    # 000            000     000     000  000 0 000  000   000     000     000       
    # 00000000  0000000      000     000  000   000  000   000     000     00000000  
    
    estimate: (@verbose) ->
        
        # ● estimate
        
        score = @score()
        ip = 0
        if @chains.length > 1
        
            qmark = []
            for area in @areas
                if area.color == '?'
                    qmark.push area
                    
            if valid qmark and global.test
                @fancySchmanzy()
                @deadOrAlive()
              
            for area in qmark
                ip += @estimateArea area
        
            if score != 'B+0'
                if score[0]=='W'
                    ip += int score[2..]
                else 
                    ip -= int score[2..]
            ip = ip.toFixed 1
        ip
        
    estimateArea: (area) ->
        
        area.infl = []
        for p in area.posl
            area.infl.push @influence @coord p
            
        @inflinfl area
        @inflinfl area
        @inflinfl area
                
        ip = area.infl.reduce (a,v) -> a+v
        ip

    influence: (c) ->

        sd = [[1 0] [0 1] [-1 0] [0 -1]]
        dd = [[1 1] [-1 1] [1 -1] [-1 -1]]
        iv = 0

        for d in sd
            n = [c[0]+d[0], c[1]+d[1]]
            s = @stoneAt n
            if s in [stone.black, stone.white]
                g = @groupAt @pos n
                if g.state != 'dead'
                    switch s 
                        stone.black ➜ iv -= 1
                        stone.white ➜ iv += 1

        for d in dd
            n = [c[0]+d[0], c[1]+d[1]]
            s = @stoneAt n
            if s in [stone.black, stone.white]
                g = @groupAt @pos n
                if g.state != 'dead'
                    switch s 
                        stone.black ➜ iv -= 0.5
                        stone.white ➜ iv += 0.5
        clamp -1 1 iv/2

    inflinfl: (area) ->
        
        infl = copy area.infl
        for p,i in area.posl
            if area.infl[i] == 0
                c = @coord p
                nd = [[1 0] [0 1] [-1 0] [0 -1] [1 1] [-1 1] [1 -1] [-1 -1]]
                iv = 0
                nc = 0
                for d in nd
                    n = [c[0]+d[0], c[1]+d[1]]
                    np = @pos n
                    if np in area.posl
                        if pi = infl[area.posl.indexOf np]
                            nc++
                            iv += pi
                area.infl[i] = iv/nc if nc
        
module.exports = Estimate
