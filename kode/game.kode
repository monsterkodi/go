###
 0000000    0000000   00     00  00000000
000        000   000  000   000  000     
000  0000  000000000  000000000  0000000 
000   000  000   000  000 0 000  000     
 0000000   000   000  000   000  00000000
###

kxk = require 'kxk'

{ randInt, elem, $ } = kxk
{ opponent, alpha, stone } = require './util'

Score = require './score'
Grid  = require './grid'

function Game extends Score

    @: (@board) ->
        
        @grid  = new Grid()
        @moves = []
        @boardsize @board.size
        
    boardsize: (@size) -> @clear_board()
    
    save: ->
        
        window.stash.set 'moves' @moves
        window.stash.set 'grid'  @grid.grid
            
    move_history: -> @moves.join '\n'
            
    nextColor: ->
        
        switch @moves.length%2
            0 ➜ 'B'
              ➜ 'W'
        
    #  0000000   00000000  000   000  00     00   0000000   000   000  00000000  
    # 000        000       0000  000  000   000  000   000  000   000  000       
    # 000  0000  0000000   000 0 000  000000000  000   000   000 000   0000000   
    # 000   000  000       000  0000  000 0 000  000   000     000     000       
    #  0000000   00000000  000   000  000   000   0000000       0      00000000  
    
    genmove: (color) ->
        
        color ?= @nextColor()
        l = @all_legal color
        
        if @moves.length and @moves[-1].endsWith 'pass'
            return 'pass'
        
        if valid l
            p = l[randInt l.length]
            @play color, p
            p
        else
            'pass'
        
    # 00000000   000       0000000   000   000  
    # 000   000  000      000   000   000 000   
    # 00000000   000      000000000    00000    
    # 000        000      000   000     000     
    # 000        0000000  000   000     000     
    
    play: (color, p) ->

        if p.toLowerCase() == 'pass' 
            @moves.push color + ' ' + p.toLowerCase()
            @updateTitle()
            return ''
            
        if not p 
            p = color
            color = @nextColor()
            
        c = @coord p
        if @valid c
            @setStone c, stone[color]
            @moves.push color + ' ' + p
            @capture opponent[color]
            @board.lastMove()
            @updateTitle()
            ''
        else
            '? invalid color or coordinate'
            
    #  0000000  00000000  000000000   0000000  000000000   0000000   000   000  00000000  
    # 000       000          000     000          000     000   000  0000  000  000       
    # 0000000   0000000      000     0000000      000     000   000  000 0 000  0000000   
    #      000  000          000          000     000     000   000  000  0000  000       
    # 0000000   00000000     000     0000000      000      0000000   000   000  00000000  
    
    setStone: (c, s) ->
        
        @grid.set c, s
        if s == stone.empty
            @board.delStone c
        else
            @board.addStone c, s
            
    #  0000000  000   000   0000000   000   000  
    # 000       000   000  000   000  000 0 000  
    # 0000000   000000000  000   000  000000000  
    #      000  000   000  000   000  000   000  
    # 0000000   000   000   0000000   00     00  
    
    show: (data) ->

        @board.clear()
        @grid.clear()
        rs = data.split('\n')[2..]
        rs = rs.map (r) => r[3..].split(' ').join('')
        for y in 0...@size
            r = rs[y]
            for x in 0...@size
                switch r[x]
                    'X' ➜ @setStone [x,y] stone.black
                    'O' ➜ @setStone [x,y] stone.white
                 
            if 'hascaptured' in r
                captured = int r.split('hascaptured')[1]
                if 'WHITE' in r
                    @captures.white = captured
                else
                    @captures.black = captured
                    
        @board.liberties()
        @updateTitle()
            
    #  0000000   0000000   00000000   000000000  000   000  00000000   00000000
    # 000       000   000  000   000     000     000   000  000   000  000     
    # 000       000000000  00000000      000     000   000  0000000    0000000 
    # 000       000   000  000           000     000   000  000   000  000     
    #  0000000  000   000  000           000      0000000   000   000  00000000
    
    capture: (color) ->
        
        for p in @allStones color
            c = @coord p
            if @liberties(c) < 1
                g = @group c
                @captures[opponent[color]] += g.length
                for dp in g
                    dc = @coord dp
                    @setStone dc, stone.empty
                @capture color
                return
                        
    next: (num=1) ->
        
        for i in 0...num
            @genmove()
        @showboard()
        
    black: (p) -> @play 'B' p
    white: (p) -> @play 'W' p
    color: (p) ->
        
        switch @stoneAt @coord p
            '○' ➜ 'black'
            '●' ➜ 'white'
                ➜ 'empty'
        
    #  0000000  000      00000000   0000000   00000000 
    # 000       000      000       000   000  000   000
    # 000       000      0000000   000000000  0000000  
    # 000       000      000       000   000  000   000
    #  0000000  0000000  00000000  000   000  000   000
    
    clear_board: ->
        
        @captures = black:0 white:0
        @grid.clear @size
        @moves = []
        @updateTitle()
        ''
            
    #  0000000  000   000   0000000   000   000 
    # 000       000   000  000   000  000 0 000 
    # 0000000   000000000  000   000  000000000 
    #      000  000   000  000   000  000   000 
    # 0000000   000   000   0000000   00     00 
    
    showboard: ->

        s = ' '
        b = '  '
        b += alpha.slice(0,@size) each (v) -> s + v
        b += '\n'
        y = 0
        for i in @size..1
            b += lpad 2, i
            b += s
            for x in 0...@size
                b += @stoneAt(x,y) + s
            b += i
            b += '\n'
            y++
            
        b += '  '
        b += alpha.slice(0,@size) each (v) -> s + v
        b += '\n'
        b
        
    dump: ->
        
        log @showboard()
        log 'white' @allStones('w').length, @allStones 'w'
        log 'black' @allStones('b').length, @allStones 'b'
        log @grid.toString()
        
    setScore: (@score) -> 
    
        log 'game.setScore' @score
        @calcScore()
        @board.annotate()
        @updateTitle()
        
    # 000000000  000  000000000  000      00000000  
    #    000     000     000     000      000       
    #    000     000     000     000      0000000   
    #    000     000     000     000      000       
    #    000     000     000     0000000  00000000  
    
    updateTitle: ->
        
        t =$ '.titlebar-title'
        t.innerHTML = ''
        td = elem 'div' class:'captures' parent:t
        
        bs = @score?[0] == 'B' ? @score[2..] : '  '
        ws = @score?[0] == 'W' ? @score[2..] : '  '
        
        elem 'span' class:'capture black' text: bs + ' ' + @captures.black + stone.black, parent:td
        elem 'span' class:'capture white' text: stone.white + @captures.white + ' ' + ws, parent:td
        
    finalScore: (score) ->
        
        t =$ '.titlebar-title'
        t.innerHTML = ''
        td = elem 'div' class:'captures' text:score, parent:t
        
module.exports = Game
