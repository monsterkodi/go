###
 0000000    0000000   00     00  00000000
000        000   000  000   000  000     
000  0000  000000000  000000000  0000000 
000   000  000   000  000 0 000  000     
 0000000   000   000  000   000  00000000
###

kxk = require 'kxk'
{ randInt, elem, $ } = kxk
{ opponent, alpha, stone, splice } = require './util'
Score = require './score'

function Game extends Score

    @: (@board) ->
        
        @moves = []
        @boardsize @board.size
        
    save: ->
        
        window.stash.set 'moves' @moves
        window.stash.set 'grid'  @grid
    
    # 000      00000000   0000000    0000000   000      
    # 000      000       000        000   000  000      
    # 000      0000000   000  0000  000000000  000      
    # 000      000       000   000  000   000  000      
    # 0000000  00000000   0000000   000   000  0000000  
    
    legal: (color, c) ->
        
        fr = @freedoms color, c
        mc = @movecaptures color, c
        @stoneAt(c) == stone.empty and (fr or mc)
        
    all_legal: (color) ->
        
        color ?= @nextColor()
        l = []
        for y in 0...@size
            for x in 0...@size
                if @legal color, [x,y]
                    l.push @pos [x,y]
        l
        
    # 000      000  0000000    00000000  00000000   000000000  000  00000000   0000000  
    # 000      000  000   000  000       000   000     000     000  000       000       
    # 000      000  0000000    0000000   0000000       000     000  0000000   0000000   
    # 000      000  000   000  000       000   000     000     000  000            000  
    # 0000000  000  0000000    00000000  000   000     000     000  00000000  0000000   
    
    countlib: (p) -> @liberties @coord p
    liberties: (c) ->
        if @valid c
            s = @stoneAt c
            if s != stone.empty
                g = @group c
                n = @group_neighbors g
                n = n.filter (p) => stone.empty == @stoneAt @coord p
                return n.length
        0
        
    # 00000000  00000000   00000000  00000000  0000000     0000000   00     00   0000000  
    # 000       000   000  000       000       000   000  000   000  000   000  000       
    # 000000    0000000    0000000   0000000   000   000  000   000  000000000  0000000   
    # 000       000   000  000       000       000   000  000   000  000 0 000       000  
    # 000       000   000  00000000  00000000  0000000     0000000   000   000  0000000   
    
    free: (color, p) -> @freedoms color, @coord p
    freedoms: (color, c) ->

        l = 0
        for n in @neighbors c
            s = @stoneAt n
            if s == stone.empty then l++
            else if s == stone[color]
                if @liberties(n) > 1
                    l++
        l

    #  0000000   00000000    0000000   000   000  00000000   
    # 000        000   000  000   000  000   000  000   000  
    # 000  0000  0000000    000   000  000   000  00000000   
    # 000   000  000   000  000   000  000   000  000        
    #  0000000   000   000   0000000    0000000   000        
    
    group: (c) ->
        
        s = @stoneAt c
        g = [@pos c]
        f = [@pos c]
        while fp = f.shift()
            for n in @neighbors @coord fp
                if s == @stoneAt n
                    p = @pos n
                    if p not in g
                        g.push p
                        if p not in f then f.push p
        g
        
    group_neighbors: (g) ->
        
        gn = []
        for p in g
            for n in @poslist @neighbors @coord p
                if n not in g and n not in gn
                    gn.push n
        gn
        
        
    neighbors: (c) ->
        ns = []
        for [x,y] in [[-1 0] [1 0] [0 -1] [0 1]]
            n = [c[0]+x, c[1]+y]
            if @valid n
                ns.push n
        ns
        
    movecaptures: (color, c) ->

        m = stone[color]
        for n in @neighbors c
            s = @stoneAt n
            if s != 'empty' and s != m
                if 1 == @freedoms opponent(color), n
                    return true
        false            
        
    move_history: -> @moves.join '\n'
            
    nextColor: ->
        
        switch @moves.length%2
            0 ➜ 'B'
              ➜ 'W'
        
    #  0000000   00000000  000   000  00     00   0000000   000   000  00000000  
    # 000        000       0000  000  000   000  000   000  000   000  000       
    # 000  0000  0000000   000 0 000  000000000  000   000   000 000   0000000   
    # 000   000  000       000  0000  000 0 000  000   000     000     000       
    #  0000000   00000000  000   000  000   000   0000000       0      00000000  
    
    genmove: (color) ->
        
        color ?= @nextColor()
        l = @all_legal color
        
        if @moves.length and @moves[-1].endsWith 'pass'
            return 'pass'
        
        if valid l
            p = l[randInt l.length]
            @play color, p
            p
        else
            'pass'
        
    # 00000000   000       0000000   000   000  
    # 000   000  000      000   000   000 000   
    # 00000000   000      000000000    00000    
    # 000        000      000   000     000     
    # 000        0000000  000   000     000     
    
    play: (color, p) ->

        if p.toLowerCase() == 'pass' 
            @moves.push color + ' ' + p.toLowerCase()
            @updateTitle()
            return ''
            
        if not p 
            p = color
            color = @nextColor()
            
        c = @coord p
        if @valid c
            @setStone c, color
            @moves.push color + ' ' + p
            @removeDead opponent color
            @board.lastMove color, c
            ''
        else
            '? invalid color or coordinate'
            
    #  0000000  00000000  000000000   0000000  000000000   0000000   000   000  00000000  
    # 000       000          000     000          000     000   000  0000  000  000       
    # 0000000   0000000      000     0000000      000     000   000  000 0 000  0000000   
    #      000  000          000          000     000     000   000  000  0000  000       
    # 0000000   00000000     000     0000000      000      0000000   000   000  00000000  
    
    setStone: (c, color) ->
        
        @grid = splice @grid, @gridx(c), 1, stone[color]
        if color == 'empty'
            @board.delStone c
        else
            @board.addStone c, color
            
            
    #  0000000  000   000   0000000   000   000  
    # 000       000   000  000   000  000 0 000  
    # 0000000   000000000  000   000  000000000  
    #      000  000   000  000   000  000   000  
    # 0000000   000   000   0000000   00     00  
    
    show: (data) ->

        @board.clear()
        @clearGrid()
        rs = data.split('\n')[2..]
        rs = rs.map (r) => r[3..].split(' ').join('')
        for y in 0...@size
            r = rs[y]
            for x in 0...@size
                switch r[x]
                    'X' ➜ @setStone [x,y] 'black'
                    'O' ➜ @setStone [x,y] 'white'
                 
            if 'hascaptured' in r
                captured = int r.split('hascaptured')[1]
                if 'WHITE' in r
                    @captures.white = captured
                else
                    @captures.black = captured
                    
        @board.liberties()
        @updateTitle()
            
    # 00000000   00000000  00     00   0000000   000   000  00000000  0000000    00000000   0000000   0000000    
    # 000   000  000       000   000  000   000  000   000  000       000   000  000       000   000  000   000  
    # 0000000    0000000   000000000  000   000   000 000   0000000   000   000  0000000   000000000  000   000  
    # 000   000  000       000 0 000  000   000     000     000       000   000  000       000   000  000   000  
    # 000   000  00000000  000   000   0000000       0      00000000  0000000    00000000  000   000  0000000    
    
    removeDead: (color) ->
        
        for p in @allStones color
            c = @coord p
            if @liberties(c) < 1
                g = @group c
                @captures[opponent color] += g.length
                for dp in g
                    dc = @coord dp
                    @setStone dc, 'empty'
                @updateTitle()
                @removeDead()
                return
        
    allStones: (color) ->
        
        s = stone[color]
        l = []
        for y in 0...@size
            for x in 0...@size
                if s == @stoneAt [x,y]
                    l.push @pos [x,y]
        l
                
    next: (num=1) ->
        
        for i in 0...num
            @genmove()
        @showboard()
    
    gridx:   (c) -> c[0]+(@size+1)*c[1]
    stoneAt: (c) => @grid[@gridx c] if @valid c
    valid: (c) => 0 <= c[0] < @size and 0 <= c[1] < @size   
    coord: (p) => [alpha.indexOf(p[0].toUpperCase()), @size-int(p[1..])]
    pos:   (c) => alpha[c[0]] + (@size-c[1])
    poslist: (cl) -> cl.map @pos
    
    black: (p) -> @play 'B' p
    white: (p) -> @play 'W' p
    color: (p) ->
        
        switch @stoneAt @coord p
            '○' ➜ 'black'
            '●' ➜ 'white'
                ➜ 'empty'
        
    boardsize: (@size) -> @clear_board()

    #  0000000  000      00000000   0000000   00000000           0000000     0000000    0000000   00000000   0000000    
    # 000       000      000       000   000  000   000          000   000  000   000  000   000  000   000  000   000  
    # 000       000      0000000   000000000  0000000            0000000    000   000  000000000  0000000    000   000  
    # 000       000      000       000   000  000   000          000   000  000   000  000   000  000   000  000   000  
    #  0000000  0000000  00000000  000   000  000   000  000000  0000000     0000000   000   000  000   000  0000000    
    
    clear_board: ->
        
        @captures = black:0 white:0
        @clearGrid()
        @moves = []
        @updateTitle()
        ''
    
    clearGrid: ->
        
        @grid = ''
        for y in 0...@size
            @grid += rpad @size, ''
            @grid += '\n' if y < @size-1
        
    #  0000000  000   000   0000000   000   000  0000000     0000000    0000000   00000000   0000000    
    # 000       000   000  000   000  000 0 000  000   000  000   000  000   000  000   000  000   000  
    # 0000000   000000000  000   000  000000000  0000000    000   000  000000000  0000000    000   000  
    #      000  000   000  000   000  000   000  000   000  000   000  000   000  000   000  000   000  
    # 0000000   000   000   0000000   00     00  0000000     0000000   000   000  000   000  0000000    
    
    showboard: ->

        s = ' '
        b = '  '
        b += alpha.slice(0,@size) each (v) -> s + v
        b += '\n'
        y = 0
        for i in @size..1
            b += lpad 2, i
            b += s
            for x in 0...@size
                b += @stoneAt([x,y]) + s
            b += i
            b += '\n'
            y++
            
        b += '  '
        b += alpha.slice(0,@size) each (v) -> s + v
        b += '\n'
        b
        
    dump: ->
        
        log @showboard()
        log 'white' @allStones('w').length, @allStones 'w'
        log 'black' @allStones('b').length, @allStones 'b'
        log @grid
        
    setScore: (@score) -> 
    
        log @score
        @calcScore()
        @updateTitle()
        
    # 000   000  00000000   0000000     0000000   000000000  00000000  000000000  000  000000000  000      00000000  
    # 000   000  000   000  000   000  000   000     000     000          000     000     000     000      000       
    # 000   000  00000000   000   000  000000000     000     0000000      000     000     000     000      0000000   
    # 000   000  000        000   000  000   000     000     000          000     000     000     000      000       
    #  0000000   000        0000000    000   000     000     00000000     000     000     000     0000000  00000000  
    
    updateTitle: ->
        
        t =$ '.titlebar-title'
        t.innerHTML = ''
        td = elem 'div' class:'captures' parent:t
        
        bs = @score?[0] == 'B' ? @score[2..] : '  '
        ws = @score?[0] == 'W' ? @score[2..] : '  '
        
        elem 'span' class:'capture black' text: bs + ' ' + @captures.black + stone.black, parent:td
        elem 'span' class:'capture white' text: stone.white + @captures.white + ' ' + ws, parent:td
        
    finalScore: (score) ->
        
        t =$ '.titlebar-title'
        t.innerHTML = ''
        td = elem 'div' class:'captures' text:score, parent:t
        
module.exports = Game
