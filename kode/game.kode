###
 0000000    0000000   00     00  00000000
000        000   000  000   000  000     
000  0000  000000000  000000000  0000000 
000   000  000   000  000 0 000  000     
 0000000   000   000  000   000  00000000
###

kxk = require 'kxk'

{ randInt, elem, $ } = kxk
{ opponent, alpha, stone } = require './util/util'

Score = require './score'
Moves = require './util/moves'
Grid  = require './util/grid'

function Game extends Score

    @: (board, white, black, @handicap) ->
        
        @info = {}
        @players = {black, white}
        super board.size
        @board = board
        @moves = new Moves
        @boardsize @board.size
        
    # 00000000  00000000    0000000   00     00  00     00   0000000   000   000  00000000   0000000  
    # 000       000   000  000   000  000   000  000   000  000   000  000   000  000       000       
    # 000000    0000000    000   000  000000000  000000000  000   000   000 000   0000000   0000000   
    # 000       000   000  000   000  000 0 000  000 0 000  000   000     000     000            000  
    # 000       000   000   0000000   000   000  000   000   0000000       0      00000000  0000000   
    
    @fromMoves: (moves) ->

        moves = moves.replace /\n+/g ' '
        moves = moves.split ' '
        
        g = new Game size:19 'sgf' 'sgf' 0

        g.addMove m for m in moves
        g
                
    boardsize: (@size) -> @clear_board()
    
    save: ->
        
        window.stash.set 'moves' @moves.history()
        window.stash.set 'grid'  @grid.toString()
            
    move_history: -> @moves.history()
            
    end:       -> @moves.end()
    start:     -> @moves.start()
    lastColor: -> @moves.lastColor()
    nextColor: -> @moves.nextColor()
    lastMove:  -> @moves.last()
    lastPos:   -> @lastMove().pos
    lastCoord: -> @coord @lastPos()
        
    #  0000000   00000000  000   000  00     00   0000000   000   000  00000000  
    # 000        000       0000  000  000   000  000   000  000   000  000       
    # 000  0000  0000000   000 0 000  000000000  000   000   000 000   0000000   
    # 000   000  000       000  0000  000 0 000  000   000     000     000       
    #  0000000   00000000  000   000  000   000   0000000       0      00000000  
    
    genmove: (color) ->
        
        color ?= @nextColor()
        l = @all_legal color
        
        if @moves.lastIsPass()
            return 'pass'
        
        if valid l
            p = l[randInt l.length]
            @play p
            p
        else
            'pass'
        
    # 00000000   000       0000000   000   000  
    # 000   000  000      000   000   000 000   
    # 00000000   000      000000000    00000    
    # 000        000      000   000     000     
    # 000        0000000  000   000     000     
    
    play: (p) ->

        color = @nextColor()
                    
        if p.toLowerCase() in ['pass' 'resign' 'illegal']
            @moves.add p.toLowerCase(), color
            @board.annotate?()
            return ''

        c = @coord p
        
        if not @legal color, c
            @moves.add "illegal_#{color}_#{p}" color
            error 'illegal move:' color, @moves.num(), p
            return '? invalid move'
            
        if @valid c
            # log color, p, @legal color, c
            @setStone c, stone[color]
            @moves.add p, color, @capture color
            @calcScore()
            @board.annotate?()
            ''
        else
            '? invalid color or coordinate'
                        
    #  0000000   0000000   00000000   000000000  000   000  00000000   00000000
    # 000       000   000  000   000     000     000   000  000   000  000     
    # 000       000000000  00000000      000     000   000  0000000    0000000 
    # 000       000   000  000           000     000   000  000   000  000     
    #  0000000  000   000  000           000      0000000   000   000  00000000
    
    capture: (color) ->
        
        s = stone[opponent[color]]
        
        @calcGroups()
        pl = []
        for dead in @grps.filter (g) -> g.libs == 0 and g.stone == s
            # log 'game.capture' color, dead.posl.length
            pl = pl.concat dead.posl
            for deadPos in dead.posl
                @removePos deadPos
        pl

    addMove: (p) ->

        # ● addMove
        color = @nextColor()
                    
        if p in ['pass' 'resign']
            @moves.add p, color
            return

        c = @coord p
        
        if cpts = @legal color, c
            for deadPos in cpts ? []
                @removePos deadPos
            @setStone c, stone[color]
            @moves.add p, color, cpts ? []
        else
            error 'illegal move:' color, @moves.num(), p
            @moves.add 'pass' color
                
    #  0000000  00000000  000000000   0000000  000000000   0000000   000   000  00000000  
    # 000       000          000     000          000     000   000  0000  000  000       
    # 0000000   0000000      000     0000000      000     000   000  000 0 000  0000000   
    #      000  000          000          000     000     000   000  000  0000  000       
    # 0000000   00000000     000     0000000      000      0000000   000   000  00000000  
    
    setStone: (c, s) ->
        
        @grid.set c, s
        if s == stone.empty
            @board.delStone? c
        else
            @board.addStone? c, s
            
    removePos: (p) ->
        
        @setStone @coord(p), stone.empty

    # 000   000  000   000  0000000     0000000   00     00   0000000   000   000  00000000  
    # 000   000  0000  000  000   000  000   000  000   000  000   000  000   000  000       
    # 000   000  000 0 000  000   000  000   000  000000000  000   000   000 000   0000000   
    # 000   000  000  0000  000   000  000   000  000 0 000  000   000     000     000       
    #  0000000   000   000  0000000     0000000   000   000   0000000       0      00000000  
    
    undoMove: (m) ->
        
        @removePos m.pos
        
        if valid m.captures
            @verb 'undoMove captures' m
            for p in m.captures
                @setStone @coord(p), stone[opponent[m.color]]
        
        @calcScore()
        @board.annotate()
            
    next: (num=1) ->
        
        for i in 0...num
            @genmove()
        @showboard()
        
    black: (p) -> @play p
    white: (p) -> @play p
    color: (p) ->
        
        switch @stoneAt @coord p
            '○' ➜ 'black'
            '●' ➜ 'white'
                ➜ 'empty'

    #  0000000  000      00000000   0000000   00000000 
    # 000       000      000       000   000  000   000
    # 000       000      0000000   000000000  0000000  
    # 000       000      000       000   000  000   000
    #  0000000  0000000  00000000  000   000  000   000
    
    clear_board: ->
        
        @moves.clear()
        @clear()
        @grid.clear()
        @board.clear?()
        @updateTitle()
        ''
            
    #  0000000  000   000   0000000   000   000 
    # 000       000   000  000   000  000 0 000 
    # 0000000   000000000  000   000  000000000 
    #      000  000   000  000   000  000   000 
    # 0000000   000   000   0000000   00     00 
    
    showboard: ->

        s = ' '
        b = '  '
        b += alpha.slice(0,@size) each (v) -> s + v
        b += '\n'
        y = 0
        for i in @size..1
            b += lpad 2, i
            b += s
            for x in 0...@size
                b += @stoneAt(x,y) + s
            b += i
            b += '\n'
            y++
            
        b += '  '
        b += alpha.slice(0,@size) each (v) -> s + v
        b += '\n'
        b
        
    setScore: (score) -> 

        if score.endsWith '.0'
            score = score[...-2]
        @info.score = score
        calc = @calcScore()
        if score != calc
            error 'game.setScore' score, '!=' calc
        @board.annotate()
        
    updateTitle: -> 

        if process.type == 'renderer'
            window?.win.updateTitle()
        
    finalScore: (score) ->
        
        @setScore score
        
module.exports = Game
