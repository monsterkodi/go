###
 0000000    0000000   00     00  00000000
000        000   000  000   000  000     
000  0000  000000000  000000000  0000000 
000   000  000   000  000 0 000  000     
 0000000   000   000  000   000  00000000
###

kxk = require 'kxk'

{ randInt, elem, $ } = kxk
{ opponent, alpha, stone } = require './util'

Score = require './score'
Moves = require './moves'
Grid  = require './grid'

function Game extends Score

    @: (board, white, black, @handicap) ->
        
        @players = {black, white}
        super board.size
        @board = board
        @moves = new Moves
        @boardsize @board.size
        
    boardsize: (@size) -> @clear_board()
    
    save: ->
        
        window.stash.set 'moves' @moves
        window.stash.set 'grid'  @grid.toString()
            
    move_history: -> @moves.history()
            
    start:     -> @moves.start()
    lastColor: -> @moves.lastColor()
    nextColor: -> @moves.nextColor()
    lastMove:  -> @moves.last().pos
    lastCoord: -> @coord @lastMove()
        
    #  0000000   00000000  000   000  00     00   0000000   000   000  00000000  
    # 000        000       0000  000  000   000  000   000  000   000  000       
    # 000  0000  0000000   000 0 000  000000000  000   000   000 000   0000000   
    # 000   000  000       000  0000  000 0 000  000   000     000     000       
    #  0000000   00000000  000   000  000   000   0000000       0      00000000  
    
    genmove: (color) ->
        
        color ?= @nextColor()
        l = @all_legal color
        
        if @moves.lastIsPass()
            return 'pass'
        
        if valid l
            p = l[randInt l.length]
            @play color, p
            p
        else
            'pass'
        
    # 00000000   000       0000000   000   000  
    # 000   000  000      000   000   000 000   
    # 00000000   000      000000000    00000    
    # 000        000      000   000     000     
    # 000        0000000  000   000     000     
    
    play: (color, p) ->

        if p.toLowerCase() == 'pass' 
            @moves.add p.toLowerCase(), color
            @updateTitle()
            return ''
            
        if not p 
            p = color
            color = @nextColor()
            
        c = @coord p
        if @valid c
            @setStone c, stone[color]
            @moves.add p, color, @capture color
            @calcScore()
            @board.annotate()
            ''
        else
            '? invalid color or coordinate'
            
    #  0000000   0000000   00000000   000000000  000   000  00000000   00000000
    # 000       000   000  000   000     000     000   000  000   000  000     
    # 000       000000000  00000000      000     000   000  0000000    0000000 
    # 000       000   000  000           000     000   000  000   000  000     
    #  0000000  000   000  000           000      0000000   000   000  00000000
    
    capture: (color) ->
        
        s = stone[opponent[color]]
        
        @calcGroups()
        
        for dead in @grps.filter (g) -> g.libs == 0 and g.stone == s
            log @captures
            @captures[color] += dead.group.length
            log noon dead
            log @captures
            for deadPos in dead.group
                @removePos deadPos
        
        # for p in @allStones color
            # c = @coord p
            # if @liberties(c) < 1
                # g = @group c
                # @captures[opponent[color]] += g.length
                # for dp in g
                    # dc = @coord dp
                    # @setStone dc, stone.empty
                # @capture color
                # return
            
    #  0000000  00000000  000000000   0000000  000000000   0000000   000   000  00000000  
    # 000       000          000     000          000     000   000  0000  000  000       
    # 0000000   0000000      000     0000000      000     000   000  000 0 000  0000000   
    #      000  000          000          000     000     000   000  000  0000  000       
    # 0000000   00000000     000     0000000      000      0000000   000   000  00000000  
    
    setStone: (c, s) ->
        
        @grid.set c, s
        if s == stone.empty
            @board.delStone c
        else
            @board.addStone c, s
            
    removePos: (p) ->
        
        @setStone @coord(p), stone.empty
            
    #  0000000  000   000   0000000   000   000  
    # 000       000   000  000   000  000 0 000  
    # 0000000   000000000  000   000  000000000  
    #      000  000   000  000   000  000   000  
    # 0000000   000   000   0000000   00     00  
    
    show: (data) ->

        @grid.clear()
        @board.clear()
        rs = data.split('\n')[2..]
        rs = rs.map (r) => r[3..].split(' ').join('')
        for y in 0...@size
            r = rs[y]
            for x in 0...@size
                switch r[x]
                    'X' ➜ @setStone [x,y] stone.black
                    'O' ➜ @setStone [x,y] stone.white
                 
            if 'hascaptured' in r
                captured = int r.split('hascaptured')[1]
                log 'captured' r, captured
                if 'WHITE' in r
                    @captures.white = captured
                else
                    @captures.black = captured
         
        @calcScore()
        @board.annotate()
                                    
    next: (num=1) ->
        
        for i in 0...num
            @genmove()
        @showboard()
        
    black: (p) -> @play 'B' p
    white: (p) -> @play 'W' p
    color: (p) ->
        
        switch @stoneAt @coord p
            '○' ➜ 'black'
            '●' ➜ 'white'
                ➜ 'empty'

    #  0000000  000      00000000   0000000   00000000 
    # 000       000      000       000   000  000   000
    # 000       000      0000000   000000000  0000000  
    # 000       000      000       000   000  000   000
    #  0000000  0000000  00000000  000   000  000   000
    
    clear_board: ->
        
        delete @redos
        @moves.clear()
        @clear()
        @grid.clear()
        @board.clear()
        @updateTitle()
        ''
            
    #  0000000  000   000   0000000   000   000 
    # 000       000   000  000   000  000 0 000 
    # 0000000   000000000  000   000  000000000 
    #      000  000   000  000   000  000   000 
    # 0000000   000   000   0000000   00     00 
    
    showboard: ->

        s = ' '
        b = '  '
        b += alpha.slice(0,@size) each (v) -> s + v
        b += '\n'
        y = 0
        for i in @size..1
            b += lpad 2, i
            b += s
            for x in 0...@size
                b += @stoneAt(x,y) + s
            b += i
            b += '\n'
            y++
            
        b += '  '
        b += alpha.slice(0,@size) each (v) -> s + v
        b += '\n'
        b
        
    dump: ->
        
        log @showboard()
        log 'white' @allStones('w').length, @allStones 'w'
        log 'black' @allStones('b').length, @allStones 'b'
        log @grid.toString()
        
    setScore: (@score) -> 
    
        # log 'game.setScore' @score
        @calcScore()
        # @board.annotate()
        
    # 000000000  000  000000000  000      00000000  
    #    000     000     000     000      000       
    #    000     000     000     000      0000000   
    #    000     000     000     000      000       
    #    000     000     000     0000000  00000000  
    
    updateTitle: ->
        
        t =$ '.titlebar-title'
        t.innerHTML = ''
        td = elem 'div' class:'captures' parent:t
        
        bs = @score?[0] == 'B' ? @score[2..] : '  '
        ws = @score?[0] == 'W' ? @score[2..] : '  '
        
        elem 'span' class:'player black'  text:@players.black + ' ', parent:td
        elem 'span' class:'capture black' text: bs + ' ' + @captures.black + stone.black, parent:td
        elem 'span' class:'capture white' text: stone.white + @captures.white + ' ' + ws, parent:td
        elem 'span' {class:'player white' text:' ' + @players.white, parent:td
        
    finalScore: (score) ->
        
        window.stash.set 'score' trim score 
        t =$ '.titlebar-title'
        t.innerHTML = ''
        td = elem 'div' class:'captures' parent:t
        
        elem 'span' {class:'player black' text:@info.players[0] + ' ', parent:td} if valid @info.players
        elem 'span'  class:"score  #{score[0] == 'B' ? 'black' : 'white'}" text:score, parent:td
        elem 'span' {class:'player white' text:' ' + @info.players[1], parent:td} if valid @info.players
        
module.exports = Game
