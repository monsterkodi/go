###
 0000000    0000000   00     00  00000000
000        000   000  000   000  000     
000  0000  000000000  000000000  0000000 
000   000  000   000  000 0 000  000     
 0000000   000   000  000   000  00000000
###

kxk = require 'kxk'

{ randInt, elem, $ } = kxk
{ opponent, alpha, stone } = require './util'

Score = require './score'
Moves = require './moves'
Grid  = require './grid'

function Game extends Score

    @: (board, white, black, @handicap) ->
        
        @players = {black, white}
        super board.size
        @board = board
        @moves = new Moves
        @boardsize @board.size
        
    boardsize: (@size) -> @clear_board()
    
    save: ->
        
        window.stash.set 'moves' @moves.history()
        window.stash.set 'grid'  @grid.toString()
            
    move_history: -> @moves.history()
            
    end:       -> @moves.end()
    start:     -> @moves.start()
    lastColor: -> @moves.lastColor()
    nextColor: -> @moves.nextColor()
    lastMove:  -> @moves.last()
    lastPos:   -> @lastMove().pos
    lastCoord: -> @coord @lastPos()
        
    #  0000000   00000000  000   000  00     00   0000000   000   000  00000000  
    # 000        000       0000  000  000   000  000   000  000   000  000       
    # 000  0000  0000000   000 0 000  000000000  000   000   000 000   0000000   
    # 000   000  000       000  0000  000 0 000  000   000     000     000       
    #  0000000   00000000  000   000  000   000   0000000       0      00000000  
    
    genmove: (color) ->
        
        color ?= @nextColor()
        l = @all_legal color
        
        if @moves.lastIsPass()
            return 'pass'
        
        if valid l
            p = l[randInt l.length]
            @play color, p
            p
        else
            'pass'
        
    # 00000000   000       0000000   000   000  
    # 000   000  000      000   000   000 000   
    # 00000000   000      000000000    00000    
    # 000        000      000   000     000     
    # 000        0000000  000   000     000     
    
    play: (color, p) ->

        if p.toLowerCase() == 'pass' 
            @moves.add p.toLowerCase(), color
            @updateTitle()
            return ''
            
        if not p 
            p = color
            color = @nextColor()
            
        c = @coord p
        if @valid c
            @setStone c, stone[color]
            @moves.add p, color, @capture color
            @calcScore()
            @board.annotate()
            ''
        else
            '? invalid color or coordinate'
            
    #  0000000   0000000   00000000   000000000  000   000  00000000   00000000
    # 000       000   000  000   000     000     000   000  000   000  000     
    # 000       000000000  00000000      000     000   000  0000000    0000000 
    # 000       000   000  000           000     000   000  000   000  000     
    #  0000000  000   000  000           000      0000000   000   000  00000000
    
    capture: (color) ->
        
        s = stone[opponent[color]]
        
        @calcGroups()
        
        for dead in @grps.filter (g) -> g.libs == 0 and g.stone == s
            log 'game.capture' color, dead.group.length
            @captures[color] += dead.group.length
            for deadPos in dead.group
                @removePos deadPos
        
    #  0000000  00000000  000000000   0000000  000000000   0000000   000   000  00000000  
    # 000       000          000     000          000     000   000  0000  000  000       
    # 0000000   0000000      000     0000000      000     000   000  000 0 000  0000000   
    #      000  000          000          000     000     000   000  000  0000  000       
    # 0000000   00000000     000     0000000      000      0000000   000   000  00000000  
    
    setStone: (c, s) ->
        
        @grid.set c, s
        if s == stone.empty
            @board.delStone c
        else
            @board.addStone c, s
            
    removePos: (p) ->
        
        @setStone @coord(p), stone.empty

    undoMove: (m) ->
        
        @removePos m.pos
        @calcScore()
        @board.annotate()
            
    #  0000000  000   000   0000000   000   000  
    # 000       000   000  000   000  000 0 000  
    # 0000000   000000000  000   000  000000000  
    #      000  000   000  000   000  000   000  
    # 0000000   000   000   0000000   00     00  
    
    show: (data) ->

        @grid.clear()
        @board.clear()
        rs = data.split('\n')[2..]
        rs = rs.map (r) => r[3..].split(' ').join('')
        for y in 0...@size
            r = rs[y]
            for x in 0...@size
                switch r[x]
                    'X' ➜ @setStone [x,y] stone.black
                    'O' ➜ @setStone [x,y] stone.white
                 
            if 'hascaptured' in r
                captured = int r.split('hascaptured')[1]
                log 'captured' r, captured
                if 'WHITE' in r
                    @captures.white = captured
                else
                    @captures.black = captured
         
        @calcScore()
        @board.annotate()
                                    
    next: (num=1) ->
        
        for i in 0...num
            @genmove()
        @showboard()
        
    black: (p) -> @play 'B' p
    white: (p) -> @play 'W' p
    color: (p) ->
        
        switch @stoneAt @coord p
            '○' ➜ 'black'
            '●' ➜ 'white'
                ➜ 'empty'

    #  0000000  000      00000000   0000000   00000000 
    # 000       000      000       000   000  000   000
    # 000       000      0000000   000000000  0000000  
    # 000       000      000       000   000  000   000
    #  0000000  0000000  00000000  000   000  000   000
    
    clear_board: ->
        
        delete @redos
        @moves.clear()
        @clear()
        @grid.clear()
        @board.clear()
        @updateTitle()
        ''
            
    #  0000000  000   000   0000000   000   000 
    # 000       000   000  000   000  000 0 000 
    # 0000000   000000000  000   000  000000000 
    #      000  000   000  000   000  000   000 
    # 0000000   000   000   0000000   00     00 
    
    showboard: ->

        s = ' '
        b = '  '
        b += alpha.slice(0,@size) each (v) -> s + v
        b += '\n'
        y = 0
        for i in @size..1
            b += lpad 2, i
            b += s
            for x in 0...@size
                b += @stoneAt(x,y) + s
            b += i
            b += '\n'
            y++
            
        b += '  '
        b += alpha.slice(0,@size) each (v) -> s + v
        b += '\n'
        b
        
    dump: ->
        
        log @showboard()
        log 'white' @allStones('w').length, @allStones 'w'
        log 'black' @allStones('b').length, @allStones 'b'
        log @grid.toString()
        
    setScore: (@score) -> 
    
        # log 'game.setScore' @score
        @calcScore()
        # @board.annotate()
        
    # 000000000  000  000000000  000      00000000  
    #    000     000     000     000      000       
    #    000     000     000     000      0000000   
    #    000     000     000     000      000       
    #    000     000     000     0000000  00000000  
    
    updateTitle: (score='') ->
        
        t =$ '.titlebar-title'
        t.innerHTML = ''
        td = elem 'div' class:'gameInfo'            parent:t
        tl = elem 'div' class:'gameInfoLeft black'  parent:td
        tm = elem 'div' class:'gameInfoCenter'      parent:td
        tr = elem 'div' class:'gameInfoRight white' parent:td
        
        scr = black: @score?[0] == 'B' ? @score[2..] : '  '
              white: @score?[0] == 'W' ? @score[2..] : '  '
        
        log 'captures' @captures, score
        mov = black:'' white:''
        if @moves.singlePass()
            mov[@lastColor()] = 'pass'
        if @moves.resigned()
            mov[@lastColor()] = 'resign'
            
        cps = black: @captures.black != 0 ? @captures.black : ''
              white: @captures.white != 0 ? @captures.white : ''
                
        elem 'span' class:'move'    parent:tl, text: mov.black
        elem 'span' class:'player'  parent:tl, text:@players.black + ' '
        elem 'span' class:'capture' parent:tl, text: scr.black + ' ' + cps.black + ' ' + stone.white
        elem 'span' class:"score #{score[0]}"  parent:tm, text: score
        elem 'span' class:'capture' parent:tr, text: stone.white + cps.white + ' ' + scr.white
        elem 'span' class:'player'  parent:tr, text: @players.white 
        elem 'span' class:'move'    parent:tr, text: mov.white
        
    finalScore: (score) ->
        
        @updateTitle score
        
module.exports = Game
