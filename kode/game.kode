###
 0000000    0000000   00     00  00000000
000        000   000  000   000  000     
000  0000  000000000  000000000  0000000 
000   000  000   000  000 0 000  000     
 0000000   000   000  000   000  00000000
###

kxk = require 'kxk'
{ randInt, elem, $ } = kxk
{ opponent, alpha, stone } = require './util'

function Game

    @: (@board) -> @boardsize @board.size
    
    # 000      00000000   0000000    0000000   000      
    # 000      000       000        000   000  000      
    # 000      0000000   000  0000  000000000  000      
    # 000      000       000   000  000   000  000      
    # 0000000  00000000   0000000   000   000  0000000  
    
    legal: (color, c) ->
        
        @stoneAt(c) == stone.empty and @freedoms color, c
        
    all_legal: (color) ->
        
        color ?= @nextColor()
        l = []
        for y in 0...@size
            for x in 0...@size
                if @legal color, [x,y]
                    l.push @pos [x,y]
        l
        
    # 000      000  0000000    00000000  00000000   000000000  000  00000000   0000000  
    # 000      000  000   000  000       000   000     000     000  000       000       
    # 000      000  0000000    0000000   0000000       000     000  0000000   0000000   
    # 000      000  000   000  000       000   000     000     000  000            000  
    # 0000000  000  0000000    00000000  000   000     000     000  00000000  0000000   
    
    countlib: (p) -> @liberties @coord p
    liberties: (c) ->
        if @valid c
            s = @stoneAt c
            if s != stone.empty
                g = @group c
                n = @group_neighbors g
                n = n.filter (p) => stone.empty == @stoneAt @coord p
                return n.length
        0
        
    #  0000000   00000000    0000000   000   000  00000000   
    # 000        000   000  000   000  000   000  000   000  
    # 000  0000  0000000    000   000  000   000  00000000   
    # 000   000  000   000  000   000  000   000  000        
    #  0000000   000   000   0000000    0000000   000        
    
    group: (c) ->
        s = @stoneAt c
        g = [@pos c]
        f = [@pos c]
        while fp = f.shift()
            for n in @neighbors @coord fp
                if s == @stoneAt n
                    p = @pos n
                    if p not in g
                        g.push p
                        if p not in f then f.push p
        g
        
    group_neighbors: (g) ->
        gn = []
        for p in g
            for n in @poslist @neighbors @coord p
                if n not in g and n not in gn
                    gn.push n
        gn
        
        
    neighbors: (c) ->
        ns = []
        for [x,y] in [[-1 0] [1 0] [0 -1] [0 1]]
            n = [c[0]+x, c[1]+y]
            if @valid n
                ns.push n
        ns
        
    # 00000000  00000000   00000000  00000000  0000000     0000000   00     00   0000000  
    # 000       000   000  000       000       000   000  000   000  000   000  000       
    # 000000    0000000    0000000   0000000   000   000  000   000  000000000  0000000   
    # 000       000   000  000       000       000   000  000   000  000 0 000       000  
    # 000       000   000  00000000  00000000  0000000     0000000   000   000  0000000   
    
    free: (color, p) -> @freedoms color, @coord p
    freedoms: (color, c) ->
        
        l = 0
        for n in @neighbors c
            s = @stoneAt n
            if s == stone.empty then l++
            else if s == stone[color]
                if @liberties(n) > 1
                    l++
        l
                
    move_history: -> @moves.join '\n'
            
    nextColor: ->
        
        switch @moves.length%2
            0 ➜ 'B'
              ➜ 'W'
        
    #  0000000   00000000  000   000  00     00   0000000   000   000  00000000  
    # 000        000       0000  000  000   000  000   000  000   000  000       
    # 000  0000  0000000   000 0 000  000000000  000   000   000 000   0000000   
    # 000   000  000       000  0000  000 0 000  000   000     000     000       
    #  0000000   00000000  000   000  000   000   0000000       0      00000000  
    
    genmove: (color) ->
        
        color ?= @nextColor()
        l = @all_legal color
        
        if @moves.length and @moves[-1].endsWith 'pass'
            return 'pass'
        
        if valid l
            p = l[randInt l.length]
            @play color, p
            p
        else
            'pass'
        
    # 00000000   000       0000000   000   000  
    # 000   000  000      000   000   000 000   
    # 00000000   000      000000000    00000    
    # 000        000      000   000     000     
    # 000        0000000  000   000     000     
    
    play: (color, p) ->

        if p.toLowerCase() == 'pass' 
            @moves.push color + ' ' + p.toLowerCase()
            @updateTitle()
            return ''
            
        if not p 
            p = color
            color = @nextColor()
            
        c = @coord p
        if @valid c
            # log 'GAME.play' color, p
            @setStone c, color
            @moves.push color + ' ' + p
            @removeDead opponent color
            @board.lastMove color, c
            ''
        else
            '? invalid color or coordinate'
            
    setStone: (c, color) ->
        
        if color == 'empty'
            @board.delStone c
        else
            @board.addStone c, color
        r = @rows[c[1]]
        @rows[c[1]] = r.slice(0, c[0]) + stone[color] + r.slice(c[0]+1)
            
    # 00000000   00000000  00     00   0000000   000   000  00000000  0000000    00000000   0000000   0000000    
    # 000   000  000       000   000  000   000  000   000  000       000   000  000       000   000  000   000  
    # 0000000    0000000   000000000  000   000   000 000   0000000   000   000  0000000   000000000  000   000  
    # 000   000  000       000 0 000  000   000     000     000       000   000  000       000   000  000   000  
    # 000   000  00000000  000   000   0000000       0      00000000  0000000    00000000  000   000  0000000    
    
    removeDead: (color) ->
        
        for p in @allstones color
            c = @coord p
            if @liberties(c) < 1
                g = @group c
                @captures[opponent color] += g.length
                for dp in g
                    dc = @coord dp
                    @setStone dc, 'empty'
                @updateTitle()
                @removeDead()
                return
        
    allstones: (color) ->
        
        s = stone[color]
        l = []
        for y in 0...@size
            for x in 0...@size
                if s == @stoneAt [x,y]
                    l.push @pos [x,y]
        l
                
    next: (num=1) ->
        
        for i in 0...num
            @genmove()
        @showboard()
    
    stoneAt: (c) => @rows[c[1]][c[0]]
    valid: (c) => 0 <= c[0] < @size and 0 <= c[1] < @size   
    coord: (p) => [alpha.indexOf(p[0].toUpperCase()), @size-int(p[1..])]
    pos:   (c) => alpha[c[0]] + (@size-c[1])
    poslist: (cl) -> cl.map @pos
    
    black: (p) -> @play 'B' p
    white: (p) -> @play 'W' p
    color: (p) ->
        
        switch @stoneAt @coord p
            '○' ➜ 'black'
            '●' ➜ 'white'
                ➜ 'empty'
        
    boardsize: (@size) -> @clear_board()

    #  0000000  000      00000000   0000000   00000000           0000000     0000000    0000000   00000000   0000000    
    # 000       000      000       000   000  000   000          000   000  000   000  000   000  000   000  000   000  
    # 000       000      0000000   000000000  0000000            0000000    000   000  000000000  0000000    000   000  
    # 000       000      000       000   000  000   000          000   000  000   000  000   000  000   000  000   000  
    #  0000000  0000000  00000000  000   000  000   000  000000  0000000     0000000   000   000  000   000  0000000    
    
    clear_board: ->
        
        @captures = black:0 white:0
        @rows = []
        for y in 0...@size
            @rows.push rpad @size, ''
        @moves = []
        @updateTitle()
        ''
        
    #  0000000  000   000   0000000   000   000  0000000     0000000    0000000   00000000   0000000    
    # 000       000   000  000   000  000 0 000  000   000  000   000  000   000  000   000  000   000  
    # 0000000   000000000  000   000  000000000  0000000    000   000  000000000  0000000    000   000  
    #      000  000   000  000   000  000   000  000   000  000   000  000   000  000   000  000   000  
    # 0000000   000   000   0000000   00     00  0000000     0000000   000   000  000   000  0000000    
    
    showboard: ->

        s = ' '
        b = '  '
        b += alpha.slice(0,@size) each (v) -> s + v
        b += '\n'
        y = 0
        for i in @size..1
            b += lpad 2, i
            b += s
            for x in 0...@size
                b += @stoneAt([x,y]) + s
            b += i
            b += '\n'
            y++
            
        b += '  '
        b += alpha.slice(0,@size) each (v) -> s + v
        b += '\n'
        b
        
    # 000   000  00000000   0000000     0000000   000000000  00000000  000000000  000  000000000  000      00000000  
    # 000   000  000   000  000   000  000   000     000     000          000     000     000     000      000       
    # 000   000  00000000   000   000  000000000     000     0000000      000     000     000     000      0000000   
    # 000   000  000        000   000  000   000     000     000          000     000     000     000      000       
    #  0000000   000        0000000    000   000     000     00000000     000     000     000     0000000  00000000  
    
    updateTitle: ->
        
        t =$ '.titlebar-title'
        t.innerHTML = ''
        td = elem 'div' class:'captures' parent:t
        elem 'span' class:'capture black' text: @captures.black + stone.black, parent:td
        elem 'span' class:'capture white' text: stone.white + @captures.white, parent:td
        
    finalScore: (score) ->
        
        t =$ '.titlebar-title'
        t.innerHTML = ''
        td = elem 'div' class:'captures' text:score, parent:t
        
module.exports = Game
