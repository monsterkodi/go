###
 0000000    0000000   00     00  00000000
000        000   000  000   000  000     
000  0000  000000000  000000000  0000000 
000   000  000   000  000 0 000  000     
 0000000   000   000  000   000  00000000
###

{ randInt } = require 'kxk'

alpha = 'ABCDEFGHJKLMNOPQRST'
stone = black:'○' white:'●' empty:' ' B:'○' W:'●' b:'○' w:'●'

function Game

    @: -> 
        
        @boardsize 9
        # @play 'b' 'b1'
        # @play 'b' 'b2'
        # @play 'b' 'a2'
    
    legal: (color, c) ->
        
        @stoneAt(c) == stone.empty and @freedoms color, c
        
    all_legal: (color) ->
        
        color ?= @nextColor()
        l = []
        for y in 0...@size
            for x in 0...@size
                if @legal color, [x,y]
                    l.push @pos [x,y]
        l
        
    countlib: (p) -> @liberties @coord p
    liberties: (c) ->
        if @valid c
            s = @stoneAt c
            if s != stone.empty
                g = @group c
                n = @group_neighbors g
                n = n.filter (p) => stone.empty == @stoneAt @coord p
                return n.length
        0
        
    group: (c) ->
        s = @stoneAt c
        g = [@pos c]
        f = [@pos c]
        while fp = f.shift()
            for n in @neighbors @coord fp
                if s == @stoneAt n
                    p = @pos n
                    if p not in g
                        g.push p
                        if p not in f then f.push p
        g
        
    group_neighbors: (g) ->
        gn = []
        for p in g
            for n in @poslist @neighbors @coord p
                if n not in g and n not in gn
                    gn.push n
        gn
        
        
    neighbors: (c) ->
        ns = []
        for [x,y] in [[-1 0] [1 0] [0 -1] [0 1]]
            n = [c[0]+x, c[1]+y]
            if @valid n
                ns.push n
        ns
        
    free: (color, p) -> @freedoms color, @coord p
    freedoms: (color, c) ->
        
        l = 0
        for n in @neighbors c
            s = @stoneAt n
            if s == stone.empty then l++
            else if s == stone[color]
                if @liberties(n) > 1
                    l++
        l
        
    valid: (c) -> 0 <= c[0] < @size and 0 <= c[1] < @size
        
    move_history: -> @moves.join '\n'
            
    nextColor: ->
        
        switch @moves.length%2
            0 ➜ 'B'
              ➜ 'W'
        
    genmove: (color) ->
        
        color ?= @nextColor()
        l = @all_legal color
        
        if @moves.length and @moves[-1].endsWith 'pass'
            return 'pass'
        
        if valid l
            p = l[randInt l.length]
            @play color, p
            p
        else
            'pass'
        
    play: (color, p) ->
        
        if p.toLowerCase() == 'pass' 
            @moves.push color + ' ' + p.toLowerCase()
            return ''
        if not p 
            p = color
            color = @nextColor()
        c = @coord p
        if @valid c
            r = @rows[c[1]]
            @rows[c[1]] = r.slice(0, c[0]) + stone[color] + r.slice(c[0]+1)
            @moves.push color + ' ' + p
            ''
        else
            '? invalid color or coordinate'
            
    next: (num=1) ->
        
        for i in 0...num
            @genmove()
        @showboard()
    
    stoneAt: (c) => @rows[c[1]][c[0]]
        
    coord: (p) => [alpha.indexOf(p[0].toUpperCase()), @size-int(p[1..])]
    pos:   (c) => alpha[c[0]] + (@size-c[1])
    poslist: (cl) -> cl.map @pos
    
    black: (p) -> @play 'B' p
    white: (p) -> @play 'W' p
    color: (p) ->
        
        switch @stoneAt @coord p
            '○' ➜ 'black'
            '●' ➜ 'white'
                ➜ 'empty'
        
    boardsize: (@size) -> @clear_board()

    clear_board: ->
        
        @rows = []
        for y in 0...@size
            @rows.push rpad @size, ''
        @moves = []
        ''
        
    showboard: ->

        s = ' '
        b = '  '
        b += alpha.slice(0,@size) each (v) -> s + v
        b += '\n'
        y = 0
        for i in @size..1
            b += lpad 2, i
            b += s
            for x in 0...@size
                b += @stoneAt([x,y]) + s
            b += i
            b += '\n'
            y++
            
        b += '  '
        b += alpha.slice(0,@size) each (v) -> s + v
        b += '\n'
        b

module.exports = Game
