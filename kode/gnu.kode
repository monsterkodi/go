###
 0000000   000   000  000   000
000        0000  000  000   000
000  0000  000 0 000  000   000
000   000  000  0000  000   000
 0000000   000   000   0000000 
###

{ childp } = require 'kxk'
{ stone }  = require './util'

function GNU

    @: (@game) ->
        
        @msg = []
        @gnu = childp.spawn '/usr/local/bin/gnugo' [
            '--mode' 'gtp' 
            '--autolevel' 
            '--never-resign'
            ]
        @gnu.stdout.on 'data' @onData
        
    newGame: (boardsize, @color, @handicap, genmove) ->
        
        @send "boardsize #{boardsize}"
        @send "time_settings 300 10 3"
        @send "fixed_handicap #{handicap}" if @handicap > 1
        if @color == 'white'
            @human = 'black'
            @send "genmove #{@color}" if genmove and @handicap > 1
        else
            @human = 'white'
            @send "genmove #{@color}" if genmove and @handicap < 2
            
    humanMove: (p) ->

        delete @redos
        @game.play @human, p
        @send "play #{@human} #{p}"
        @calcscore()
        @send "genmove #{@color}"
        
    calcscore: ->
        
        @send 'estimate_score'

    firstMove: ->
        
        return if empty @game.moves
        @redos = @game.moves.concat @redos
        @send "boardsize #{@game.size}"
        @game.clear_board()
                
    undo: ->
        
        return if empty @game.moves
        return if valid @msg
        
        @redos ?= []
        @send 'undo'
        @redos.unshift @game.moves.pop()
        @send 'showboard'
        @calcscore()
        
    lastMove: ->

        return if empty @redos
        while valid @redos
            move = @redos.shift()
            [color, p] = move.split ' '
            @game.play color, p
            @send "play #{color} #{p}"
        @calcscore()
            
    redo: ->
        
        return if empty @redos
        return if valid @msg
        
        move = @redos.shift()
        # log 'redo' move
        [color, p] = move.split ' '
        @game.play color, p
        @send "play #{color} #{p}"
        @calcscore() if @game.moves.length > 2
        
    send: (m) -> @msg.push m; @gnu.stdin.write m + '\n'

    onData: (chunk) =>
        
        data = String chunk
        
        if @partial 
            data = @partial + data
            delete @partial
                    
        while data.startsWith '= \n\n'
            data = data[4..]
            @msg.shift()

        if not data.endsWith '\n\n'
            @partial = data
            return
     
        # log @msg
        # log data
            
        if data[0] == '='
            m = @msg.shift()
            data = data[2..]
            if m.startsWith 'genmove'
                p = data.split('\n')[0]
                if p in ['PASS' 'resign']
                    @send 'final_score'
                @game.play @color, p
                @game.calcScore()
                @game.board.annotate()
            else if m.startsWith 'fixed_handicap'
                for p in data.split ' '
                    @game.setStone @game.coord(p), stone.black
                # @game.dump()
            else if m.startsWith 'estimate_score'
                @game.setScore data.split(' ')[0]
            else if m.startsWith 'final_score'
                @game.finalScore data
            else if m.startsWith 'showboard'
                @game.show data
            else
                log m, data
        else
            m = @msg.shift()
            error m, data

module.exports = GNU
