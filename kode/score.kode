###
 0000000   0000000   0000000   00000000   00000000
000       000       000   000  000   000  000     
0000000   000       000   000  0000000    0000000 
     000  000       000   000  000   000  000     
0000000    0000000   0000000   000   000  00000000
###

{ stoneColor, stone, alpha, ilpha, opponent, short } = require './util/util'
{ fs } = require 'kxk'
{ min } = Math
Grid = require './util/grid'
Calc = require './calc'
# DeadStones = require '@sabaki/deadstones'

SORT = true

function Score extends Calc

    @: (a) ->
        
        @grid = new Grid a
        @size = @grid.size
        
    clear: ->
        
        @grid.clear @size
        
    #  0000000   0000000   000       0000000   0000000   0000000   0000000   00000000   00000000  
    # 000       000   000  000      000       000       000       000   000  000   000  000       
    # 000       000000000  000      000       0000000   000       000   000  0000000    0000000   
    # 000       000   000  000      000            000  000       000   000  000   000  000       
    #  0000000  000   000  0000000   0000000  0000000    0000000   0000000   000   000  00000000  
        
    calcScore: (@verbose) ->
        
        # ● calcScore
            
        @calcGroups()
        @linkAreas()
        @linkGroups()
        @calcChains()
        @calcAreas()
               
        return 'B+0' if @chains.length < 2
        return 'B+0' if @areas.length  < 2
                    
        @weaklings()
        @suicidals()
        
        for g in @grps
            @verb g.state, g.key
  
        @deadOrAlive() if @verbose
        
        # binary = @grid.toBinarray()
        # DeadStones.guess(binary).then (guess) ->
            # log noon guess
            
        dead = @grps.filter (g) -> g.state == 'dead'
         
        if @moves
            points = black:@moves.p[0], white:@moves.p[1]
        else
            points = black:0 white:0

        @verb 'prisoners' points
            
        for a in @areas
            if a.color in 'wb'
                @verb 'add area points' @areas.indexOf(a), a.color, a.posl.length
                points[stoneColor[a.color]] += a.posl.length

        for dg in dead
            @verb 'add dead group points' @grps.indexOf(dg), opponent[stoneColor[dg.stone]], dg.posl.length*2
            for dp in dg.posl
                points[opponent[stoneColor[dg.stone]]] += 2

        @verb 'points' points
                        
        if points.white > points.black
            finalScore = 'W+'+(points.white-points.black)
        else
            finalScore = 'B+'+(points.black-points.white)
          
        @verb 'score.calcScore' finalScore
        finalScore
        
    # 000   000  00000000   0000000   000   000  000      000  000   000   0000000    0000000  
    # 000 0 000  000       000   000  000  000   000      000  0000  000  000        000       
    # 000000000  0000000   000000000  0000000    000      000  000 0 000  000  0000  0000000   
    # 000   000  000       000   000  000  000   000      000  000  0000  000   000       000  
    # 00     00  00000000  000   000  000   000  0000000  000  000   000   0000000   0000000   
    
    weaklings: ->
        
        for g in @grps
            # if g.state not in ['alive' 'dead']
            if g.state not in ['dead']
                if g.libs == 1
                    @deadGroups [g], 'weakling 1 lib'
                    continue
                
    #  0000000  000   000  000   0000000  000  0000000     0000000   000       0000000  
    # 000       000   000  000  000       000  000   000  000   000  000      000       
    # 0000000   000   000  000  000       000  000   000  000000000  000      0000000   
    #      000  000   000  000  000       000  000   000  000   000  000           000  
    # 0000000    0000000   000   0000000  000  0000000    000   000  0000000  0000000   
    
    suicidals: ->
        
        for g in @grps
            if g.state not in ['alive' 'dead']
                if g.areas.length == 2
                    for ai in g.areas
                        a = @areas[ai]
                        if @suicidalArea a
                            if ch = @chains[g.chain]
                                if ch.areas.length == ch.libs
                                    @deadChains [ch] 'chain at suicidal area with as many libs as areas!'
                                    break
                    
    #  0000000   0000000   000       0000000   0000000   00000000    0000000   000   000  00000000    0000000  
    # 000       000   000  000      000       000        000   000  000   000  000   000  000   000  000       
    # 000       000000000  000      000       000  0000  0000000    000   000  000   000  00000000   0000000   
    # 000       000   000  000      000       000   000  000   000  000   000  000   000  000             000  
    #  0000000  000   000  0000000   0000000   0000000   000   000   0000000    0000000   000        0000000   
    
    calcGroups: ->
        
        @grps  = []
        @areas = []
        
        allg = @allGroups()
        for s,gl of allg
            for g in gl
                n = @groupNeighbors g
                g.sort() if SORT
                n.sort() if SORT
                if s == stone.empty
                    @areas.push 
                        color: @areaColor g
                        key:   g.join ' '
                        grps:  []
                        posl:  g
                        neighbors: n
                else
                    @grps.push
                        stone: s
                        key:   g.join ' '
                        state: 'unknown'
                        areas: []
                        eyes:  []
                        links: []
                        libs:  n.filter((p) => stone.empty == @stoneAt @coord p).length
                        posl:  g
                        neighbors: n
                        diagonals: @poslDiagonals g, n

    groupIndex: (g) -> @grps.indexOf g
    isLinked: (a,b) -> @groupIndex(b) in a.links
        
    createLink: (a,b) ->
        
        return if @isLinked a,b
        
        ai = @groupIndex a
        bi = @groupIndex b
        
        a.links.push bi if bi not in a.links
        b.links.push ai if ai not in b.links
        
    linkGroups: ->
        
        for g in @grps
            for dp in g.diagonals
                if dg = @groupAt dp
                    if dg.stone == g.stone 
                        union = @poslUnion @posNeighbors(dp), g.neighbors
                        for i in 0...union.length
                            if @stoneAt(union[i]) == stone.empty
                                @createLink g, dg
                                break
                        
    groupsShareArea: (a,b) ->
        
        for ai in a.areas
            for bi in b.areas
                return true if ai == bi
        false

    chainIndexForGroup: (g) -> 
        
        return g.chain if g.chain? 
        fi = @grps.indexOf g
        for ch in @chains
            ci = @chains.indexOf ch
            for gi in ch.grps
                return ci if fi == gi        
        -1
                        
    #  0000000   0000000   000       0000000   0000000  000   000   0000000   000  000   000   0000000  
    # 000       000   000  000      000       000       000   000  000   000  000  0000  000  000       
    # 000       000000000  000      000       000       000000000  000000000  000  000 0 000  0000000   
    # 000       000   000  000      000       000       000   000  000   000  000  000  0000       000  
    #  0000000  000   000  0000000   0000000   0000000  000   000  000   000  000  000   000  0000000   
    
    calcChains: ->
        
        @chains = []
        
        for g in @grps
            gi = @groupIndex g
            if valid g.links
                ci = g.chain
                if not ci
                    ci = @chainIndexForGroup g
                    if ci == -1
                        for li in g.links
                            ci = @chainIndexForGroup @grps[li]
                            if ci != -1 ➜ break
                    if ci == -1
                        ci = @chains.length
                        @chains.push grps:[]
                ch = @chains[ci]
                ch.grps.push gi if gi not in ch.grps
                for li in g.links
                    if li not in ch.grps
                        @grps[li].chain = ci
                        ch.grps.push li
                g.chain = ci
            else
                ci = @chains.length
                @chains.push grps:[gi]
                g.chain = ci
        
        for ch in @chains
            for oc in @chains
                if ch != oc
                    for gi in ch.grps
                        if gi in oc.grps
                            if ch.grps.length > oc.grps.length
                                @chains.splice @chains.indexOf(oc), 1
                                break
                            else
                                @chains.splice @chains.indexOf(ch), 1
                                break
                
        for ch in @chains
            ch.areas = []
            ch.posl  = []
            ch.eyes  = []
            ch.stone = @grps[ch.grps[0]].stone
            for gi in ch.grps
                ch.posl = ch.posl.concat @grps[gi].posl
                for ai in @grps[gi].areas
                    ch.areas.push ai if ai not in ch.areas
                for ai in @grps[gi].eyes
                    ch.eyes.push ai if ai not in ch.eyes
                    
            n = @poslNeighbors ch.posl
            n.sort() if SORT
            ch.posl.sort() if SORT
            ch.neighbors = n
            ch.diagonals = @poslDiagonals ch.posl, n
            ch.libs = n.filter((p) => stone.empty == @stoneAt @coord p).length
            if ch.eyes.length > 1
                onelib = ch.grps.map((gi) => @grps[gi]).filter (gr) -> gr.libs == 1
                if empty onelib
                    @aliveChains [ch], 'instant alive!'

        if @verbose
            @fancySchmanzy() 
            @deadOrAlive()
        
        return if @areas.length < 2
        
        battle = []
        for ch in @chains
            if not ch.alive                    
                if ch.areas.length == 1
                    battle.push ch.areas[0] if ch.areas[0] not in battle
                    
        for ai in battle
            @areaBattle ai
            
        for ch in @chains
            if not ch.alive and not ch.dead
                @chainBattle ch
                
        @reevaluateAreaColors()
                                
    # 00000000   00000000  00000000  000   000   0000000   000      000   000   0000000   000000000  00000000  
    # 000   000  000       000       000   000  000   000  000      000   000  000   000     000     000       
    # 0000000    0000000   0000000    000 000   000000000  000      000   000  000000000     000     0000000   
    # 000   000  000       000          000     000   000  000      000   000  000   000     000     000       
    # 000   000  00000000  00000000      0      000   000  0000000   0000000   000   000     000     00000000  
    
    reevaluateAreaColors: ->
        
        undecided = @chains.filter (ch) -> not ch.alive and not ch.dead
        
        for ch in undecided
            
            ownedAreas = 0
            
            for ai in ch.areas
                aliveOpponent = 0
                deadOpponent = 0
                ar = @areas[ai]
                for gi in ar.grps
                    g = @grps[gi]
                    if gi not in ch.grps and g.stone != ch.stone 
                        if g.state != 'dead'
                            aliveOpponent++
                        else
                            deadOpponent++
                if not aliveOpponent and deadOpponent
                    ar.color = stoneColor[ch.stone][0]
                    @aliveChains [ch], 'last opponent died'
                if ar.color == stoneColor[ch.stone][0] and not @weakEye ar
                    ownedAreas++
                    
            if ownedAreas == ch.areas.length and not ch.alive
                @aliveChains [ch], 'all areas owned'

    weakEye: (a) -> a.grps.length > 2
                
    #  0000000  000   000   0000000   000  000   000  0000000     0000000   000000000  000000000  000      00000000  
    # 000       000   000  000   000  000  0000  000  000   000  000   000     000        000     000      000       
    # 000       000000000  000000000  000  000 0 000  0000000    000000000     000        000     000      0000000   
    # 000       000   000  000   000  000  000  0000  000   000  000   000     000        000     000      000       
    #  0000000  000   000  000   000  000  000   000  0000000    000   000     000        000     0000000  00000000  
        
    chainBattle: (ch) ->

        for oc in @chains
            if oc != ch and not oc.dead
                
                if ch.libs == 1 and (oc.alive or oc.libs > 1)
                    @deadChains [ch], 'only 1 lib!'
                    return

                if ch.libs == 2 and (oc.alive or oc.libs > 2)
                    if not @looseChainConnection ch
                        @deadChains [ch], 'only 2 libs!'
                        return
                    # else
                        # log '2 libs but looseChainConnection' @chains.indexOf(ch), ch
                    
                if ch.libs < 5 and ch.areas.length == 1
                    if @deadShape @areas[ch.areas[0]]
                        @deadChains [ch], 'less than 5 libs in single area with dead shape!'
                        return
                
                lostAreas = []
                sameAreas = []
                for ai in ch.areas
                    if ai in oc.areas
                        if @areas[ai].grps.map((gi) => @grps[gi]).filter((gr) -> gr.stone == ch.stone).length == 1
                            sameAreas.push ai if @areas[ai].posl.length < 10
                        if oc.eyes.length > 0
                            chlib = @chainAreaLibs(ch, ai)
                            if chlib < 6 and chlib <  @chainAreaLibs(oc, ai) and @areas[ai].posl.length < 10
                                if @areas[ai].grps.map((gi) => @grps[gi]).filter((gr) -> gr.stone == ch.stone).length == 1
                                    lostAreas.push ai

                if lostAreas.length == ch.areas.length
                    @deadChains [ch], 'lost all areas!' + oc
                    return
                    
                if sameAreas.length == ch.areas.length and ch.areas.length <= 2 and oc.alive
                    @deadChains [ch], 'shares all areas and has less or other is alive!' + oc
                    return
        
    deadChains: (chains, reason) ->
        
        for ch in chains
            ch.dead = true
            @verb R2(y5 rpad 12 'deadChains'), reason, @colorChain ch
            @verb @chainString ch
            for gi in ch.grps
                @grps[gi].state = 'dead'
                
        @reevaluateAreaColors()
        
    deadGroups: (groups, reason) ->
        
        for gr in groups
            @verb R2(y5 rpad 12 'deadGroups'), reason, gr.key
            gr.state = 'dead'
                
        @reevaluateAreaColors()
        
    aliveChains: (chains, reason) ->
        
        for ch in chains
            ch.alive = true
            @verb G2(g5 rpad 12 'aliveChains'), reason, @colorChain ch
            for gi in ch.grps
                @grps[gi].state = 'alive'
    
    #  0000000   00000000   00000000   0000000   0000000     0000000   000000000  000000000  000      00000000  
    # 000   000  000   000  000       000   000  000   000  000   000     000        000     000      000       
    # 000000000  0000000    0000000   000000000  0000000    000000000     000        000     000      0000000   
    # 000   000  000   000  000       000   000  000   000  000   000     000        000     000      000       
    # 000   000  000   000  00000000  000   000  0000000    000   000     000        000     0000000  00000000  
    
    areaBattle: (ai) ->
        
        a = @areas[ai]
        
        return if a.posl.length > 30
        
        deadAlive = (dead, alive, reason) =>
            
            @deadChains  dead.filter((dc) -> dc.areas.length == 1), reason
            @aliveChains alive, reason
            
        chains = @chainsForArea ai
        
        return if chains.length < 2
        
        gs = []
        wc = []
        bc = []
        for ch in chains
            wc.push ch if ch.stone == stone.white
            bc.push ch if ch.stone == stone.black
            for gi in ch.grps
                gs.push @grps[gi] if gi not in gs
                
        if wc.length and bc.length
                        
            wc.sort (a,b) => @chainAreaLibs(b,ai) - @chainAreaLibs(a,ai) 
            bc.sort (a,b) => @chainAreaLibs(b,ai) - @chainAreaLibs(a,ai)
            
            wl = @chainAreaLibs wc[0],ai
            bl = @chainAreaLibs bc[0],ai
            
            if (wl - bl) > 2 and bl < 4
                if not @looseChainConnection bc[0]
                    deadAlive bc, wc, "areaBattle #{ai} white more libs #{wl} > #{bl} area size #{a.posl.length}"
            else if (bl - wl) > 2 and wl < 4
                if not @looseChainConnection wc[0]
                    deadAlive wc, bc, "areaBattle #{ai} black more libs #{bl} > #{wl} area size #{a.posl.length}" 
                     
    verb: -> if @verbose then console.log.apply null, arguments
            
module.exports = Score
