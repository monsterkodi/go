###
 0000000   0000000   0000000   00000000   00000000
000       000       000   000  000   000  000     
0000000   000       000   000  0000000    0000000 
     000  000       000   000  000   000  000     
0000000    0000000   0000000   000   000  00000000
###

{ stoneColor, stone, alpha, ilpha, opponent } = require './util/util'
{ fs } = require 'kxk'
{ min } = Math
Grid = require './util/grid'
Calc = require './calc'
DeadStones = require '@sabaki/deadstones'

function Score extends Calc

    @: (a) ->
        
        @grid = new Grid a
        @size = @grid.size
        
    clear: ->
        
        @grid.clear @size
        
    #  0000000   0000000   000       0000000   0000000   0000000   0000000   00000000   00000000  
    # 000       000   000  000      000       000       000       000   000  000   000  000       
    # 000       000000000  000      000       0000000   000       000   000  0000000    0000000   
    # 000       000   000  000      000            000  000       000   000  000   000  000       
    #  0000000  000   000  0000000   0000000  0000000    0000000   0000000   000   000  00000000  
        
    calcScore: (@verbose) ->
        
        # ● calcScore
            
        @calcGroups()
        @linkAreas()
        @linkGroups()
        @calcChains()
        
        @verb 'before calcAreas'
        @deadOrAlive() if @verbose
        
        @calcAreas()
               
        return 'B+0' if @chains.length < 2
        return 'B+0' if @areas.length  < 2
                    
        @weaklings()
        
        for g in @grps
            @verb g.state, g.key
  
        @deadOrAlive() if @verbose
        
        # log @areaString 1
        # log @deadString 1
            
        # binary = @grid.toBinarray()
        # DeadStones.guess(binary).then (guess) ->
            # log noon guess
            
        dead = @grps.filter (g) -> g.state == 'dead'
        # eyes = @areas.filter (a) -> a.color in 'wb'
        # log @groupString.apply @, dead.concat eyes
         
        # points = copy @captures
        if @moves
            points = black:@moves.p[0], white:@moves.p[1]
        else
            points = black:0 white:0
        
        for a in @areas
            if a.color in 'wb'
                points[stoneColor[a.color]] += a.posl.length

        for dg in dead
            for dp in dg.posl
                points[opponent[stoneColor[dg.stone]]] += 2

        if points.white > points.black
            finalScore = 'W+'+(points.white-points.black)
        else
            finalScore = 'B+'+(points.black-points.white)
            
        finalScore
        
    # 000   000  00000000   0000000   000   000  000      000  000   000   0000000    0000000  
    # 000 0 000  000       000   000  000  000   000      000  0000  000  000        000       
    # 000000000  0000000   000000000  0000000    000      000  000 0 000  000  0000  0000000   
    # 000   000  000       000   000  000  000   000      000  000  0000  000   000       000  
    # 00     00  00000000  000   000  000   000  0000000  000  000   000   0000000   0000000   
    
    weaklings: ->
        
        for g in @grps
            if not g.alive and not g.dead
                wc = @weakCollection g
                if valid wc
                    @verb @groupString g
                    @verb @groupString.apply @, wc
                    weak = 0
                    for wg in wc
                        if wg.libs == 1
                            weak = wc.length
                            break
                        break if wg.libs > 3
                        for ai in wg.eyes
                            if @weakEye wg, @areas[ai]
                                @verb 'weakEye' ai
                                weak++
                    if weak >= wc.length
                        @verb 'seems weak!'
                        @deadGroups wc
        
    #  0000000   0000000   000       0000000   0000000   00000000    0000000   000   000  00000000    0000000  
    # 000       000   000  000      000       000        000   000  000   000  000   000  000   000  000       
    # 000       000000000  000      000       000  0000  0000000    000   000  000   000  00000000   0000000   
    # 000       000   000  000      000       000   000  000   000  000   000  000   000  000             000  
    #  0000000  000   000  0000000   0000000   0000000   000   000   0000000    0000000   000        0000000   
    
    calcGroups: ->
        
        @grps  = []
        @areas = []
        
        allg = @allGroups()
        for s,gl of allg
            for g in gl
                n = @groupNeighbors g
                if s == stone.empty
                    @areas.push 
                        area:  g
                        posl:  g
                        key:   g.join ' '
                        grps:  []
                        color: @areaColor g
                        state: 'neutral'
                        neighbors: n
                else
                    @grps.push
                        stone: s
                        group: g
                        posl:  g
                        areas: []
                        eyes:  []
                        links: []
                        libs:  n.filter((p) => stone.empty == @stoneAt @coord p).length
                        neighbors: n
                        diagonals: @groupDiagonals g, n
                        key:   g.join ' '
                        state: 'unknown'

        # log @groupString.apply @, @grps
        # log @grpsString.apply  @, @grps
        # log @groupString.apply @, @areas
       
    groupIndex: (g) -> @grps.indexOf g
    isLinked: (a,b) -> @groupIndex(b) in a.links
        
    createLink: (a,b) ->
        
        return if @isLinked a,b
        
        ai = @groupIndex a
        bi = @groupIndex b
        
        a.links.push bi if bi not in a.links
        b.links.push ai if ai not in b.links
        
        # log @groupString.apply @, [a,b]
        
    linkGroups: ->
        
        for g in @grps
            for dp in g.diagonals
                if dg = @groupAt dp
                    # if dg.stone == g.stone and @groupsShareArea g, dg
                    if dg.stone == g.stone 
                        union = @poslUnion @posNeighbors(dp), g.neighbors
                        for i in 0...union.length
                            if @stoneAt(union[i]) == stone.empty
                                @createLink g, dg
                                break
                        
    groupsShareArea: (a,b) ->
        
        for ai in a.areas
            for bi in b.areas
                return true if ai == bi
        false

    chainIndexForGroup: (g) -> 
        
        return g.chain if g.chain? 
        fi = @grps.indexOf g
        for ch in @chains
            ci = @chains.indexOf ch
            for gi in ch.grps
                return ci if fi == gi        
        -1
                        
    #  0000000   0000000   000       0000000   0000000  000   000   0000000   000  000   000   0000000  
    # 000       000   000  000      000       000       000   000  000   000  000  0000  000  000       
    # 000       000000000  000      000       000       000000000  000000000  000  000 0 000  0000000   
    # 000       000   000  000      000       000       000   000  000   000  000  000  0000       000  
    #  0000000  000   000  0000000   0000000   0000000  000   000  000   000  000  000   000  0000000   
    
    calcChains: ->
        
        @chains = []
        
        for g in @grps
            gi = @groupIndex g
            if valid g.links
                ci = g.chain
                if not ci
                    ci = @chainIndexForGroup g
                    if ci == -1
                        for li in g.links
                            ci = @chainIndexForGroup @grps[li]
                            if ci != -1 ➜ break
                    if ci == -1
                        ci = @chains.length
                        @chains.push grps:[]
                ch = @chains[ci]
                ch.grps.push gi if gi not in ch.grps
                for li in g.links
                    if li not in ch.grps
                        @grps[li].chain = ci
                        ch.grps.push li
                g.chain = ci
            else
                ci = @chains.length
                @chains.push grps:[gi]
                g.chain = ci
        
        for ch in @chains
            for oc in @chains
                if ch != oc
                    for gi in ch.grps
                        if gi in oc.grps
                            if ch.grps.length > oc.grps.length
                                @chains.splice @chains.indexOf(oc), 1
                                break
                            else
                                @chains.splice @chains.indexOf(ch), 1
                                break
                
        # log noon @chains
                        
        for ch in @chains
            ch.areas = []
            ch.posl  = []
            ch.eyes  = []
            ch.stone = @grps[ch.grps[0]].stone
            for gi in ch.grps
                ch.posl = ch.posl.concat @grps[gi].posl
                for ai in @grps[gi].areas
                    ch.areas.push ai if ai not in ch.areas
                for ai in @grps[gi].eyes
                    ch.eyes.push ai if ai not in ch.eyes
                    
            n = @poslNeighbors ch.posl
            ch.neighbors = n
            ch.libs = n.filter((p) => stone.empty == @stoneAt @coord p).length
            if ch.eyes.length > 1
                onelib = ch.grps.map((gi) => @grps[gi]).filter (gr) -> gr.libs == 1
                if empty onelib
                    # log 'instant alive!' ch
                    @aliveChains [ch]

        # log @chainString.apply @, @chains
        
        if @verbose
            @fancySchmanzy() 
            @deadOrAlive()
        
        return if @areas.length < 2
        
        battle = []
        for ch in @chains
            if not ch.alive
                # log "chain #{@chains.indexOf ch}" ch
                # log @groupString.apply @, ch.grps.map (gi) => @grps[gi]
                # log @groupString.apply @, ch.areas.map (ai) => @areas[ai]
                # if ch.eyes.length > 0
                    # log 'got one eye'
                    # log @groupString.apply @, ch.eyes.map (ai) => @areas[ai]
                    
                if ch.areas.length == 1
                    battle.push ch.areas[0] if ch.areas[0] not in battle
                    
        for ai in battle
            @areaBattle ai
            
        for ch in @chains
            if not ch.alive and not ch.dead
                @chainBattle ch
                
        @reevaluateAreaColors()
                                
        # log @chainString.apply @, @chains
        
        # @deadOrAlive()        
        
    # 00000000   00000000  00000000  000   000   0000000   000      000   000   0000000   000000000  00000000  
    # 000   000  000       000       000   000  000   000  000      000   000  000   000     000     000       
    # 0000000    0000000   0000000    000 000   000000000  000      000   000  000000000     000     0000000   
    # 000   000  000       000          000     000   000  000      000   000  000   000     000     000       
    # 000   000  00000000  00000000      0      000   000  0000000   0000000   000   000     000     00000000  
    
    reevaluateAreaColors: ->
        
        undecided = @chains.filter (ch) -> not ch.alive and not ch.dead
        
        # log noon undecided
        
        for ch in undecided
            
            ownedAreas = 0
            
            for ai in ch.areas
                aliveOpponent = 0
                deadOpponent = 0
                ar = @areas[ai]
                for gi in ar.grps
                    g = @grps[gi]
                    if gi not in ch.grps and g.stone != ch.stone 
                        if g.state != 'dead'
                            aliveOpponent++
                        else
                            deadOpponent++
                if not aliveOpponent and deadOpponent
                    # log 'set area color' ai, stoneColor[ch.stone][0]
                    ar.color = stoneColor[ch.stone][0]
                    @aliveChains [ch]
                if ar.color == stoneColor[ch.stone][0]
                    ownedAreas++
                    
            if ownedAreas == ch.areas.length and not ch.alive
                @aliveChains [ch]

    #  0000000  000   000   0000000   000  000   000  0000000     0000000   000000000  000000000  000      00000000  
    # 000       000   000  000   000  000  0000  000  000   000  000   000     000        000     000      000       
    # 000       000000000  000000000  000  000 0 000  0000000    000000000     000        000     000      0000000   
    # 000       000   000  000   000  000  000  0000  000   000  000   000     000        000     000      000       
    #  0000000  000   000  000   000  000  000   000  0000000    000   000     000        000     0000000  00000000  
    
    chainBattle: (ch) ->

        # @verb "chainBattle #{@chains.indexOf ch}" ch

        for oc in @chains
            if oc != ch and not oc.dead
                
                if ch.libs == 1 and (oc.alive or oc.libs > 1)
                    # log 'only 1 lib!' 
                    @deadChains [ch]
                    return

                if ch.libs == 2 and (oc.alive or oc.libs > 2)
                    # log 'only 2 libs!' 
                    @deadChains [ch]
                    return
                    
                if ch.libs < 5 and ch.areas.length == 1
                    if @deadShape @areas[ch.areas[0]]
                        # log 'less than 5 libs in single area with dead shape!' 
                        @deadChains [ch]
                        return
                
                lostAreas = []
                sameAreas = []
                for ai in ch.areas
                    if ai in oc.areas
                        if @areas[ai].grps.map((gi) => @grps[gi]).filter((gr) -> gr.stone == ch.stone).length == 1
                            sameAreas.push ai if @areas[ai].posl.length < 10
                        # log "shares are #{ai} with chain #{@chains.indexOf(oc)}"
                        # if oc.eyes.length > 1
                        if oc.eyes.length > 0
                            chlib = @chainAreaLibs(ch, ai)
                            if chlib < 6 and chlib <  @chainAreaLibs(oc, ai) and @areas[ai].posl.length < 10
                                # log "lost area #{ai}" @chainAreaLibs(ch, ai), @chainAreaLibs(oc, ai)
                                if @areas[ai].grps.map((gi) => @grps[gi]).filter((gr) -> gr.stone == ch.stone).length == 1
                                    lostAreas.push ai
                # log lostAreas, lostAreas.length, ch.areas.length
                if lostAreas.length == ch.areas.length
                    @verb 'lost all areas!' oc
                    @deadChains [ch]
                    return
                    
                if sameAreas.length == ch.areas.length and ch.areas.length <= 2 and oc.alive
                    @verb 'shares all areas and has less or other is alive!' oc
                    @deadChains [ch]
                    return
        
    deadChains: (chains) ->
        
        for ch in chains
            ch.dead = true
            for gi in ch.grps
                @verb 'dead' @grps[gi].key
                @grps[gi].state = 'dead'
                
        @reevaluateAreaColors()
        
    deadGroups: (groups) ->
        
        for gr in groups
            @verb 'dead' gr.key
            gr.state = 'dead'
                
        @reevaluateAreaColors()
        
    aliveChains: (chains) ->
        
        for ch in chains
            ch.alive = true
            for gi in ch.grps
                # log 'alive' @grps[gi].key
                @grps[gi].state = 'alive'
    
    #  0000000   00000000   00000000   0000000   0000000     0000000   000000000  000000000  000      00000000  
    # 000   000  000   000  000       000   000  000   000  000   000     000        000     000      000       
    # 000000000  0000000    0000000   000000000  0000000    000000000     000        000     000      0000000   
    # 000   000  000   000  000       000   000  000   000  000   000     000        000     000      000       
    # 000   000  000   000  00000000  000   000  0000000    000   000     000        000     0000000  00000000  
    
    areaBattle: (ai) ->
        
        # log "areaBattle" ai
        
        deadAlive = (dead, alive) =>
            
            @deadChains  dead.filter (dc) -> dc.areas.length == 1
            @aliveChains alive
            
        a = @areas[ai]
        chains = @chainsForArea ai
        
        return if chains.length < 2
        
        # log "battle area #{ai}" 
        # log chains
        gs = []
        wc = []
        bc = []
        for ch in chains
            wc.push ch if ch.stone == stone.white
            bc.push ch if ch.stone == stone.black
            for gi in ch.grps
                gs.push @grps[gi] if gi not in gs
                
        # log @groupString.apply @, gs
        
        if wc.length and bc.length
                        
            wc.sort (a,b) => @chainAreaLibs(a,ai) - @chainAreaLibs(b,ai)
            bc.sort (a,b) => @chainAreaLibs(a,ai) - @chainAreaLibs(b,ai)
            
            wl = @chainAreaLibs wc[0],ai
            bl = @chainAreaLibs bc[0],ai
            
            if (wl - bl) > 2 and bl < 4
                @verb 'white more libs' wl, bl
                deadAlive bc, wc
            else if (bl - wl) > 2 and wl < 4
                @verb 'black more libs' bl, wl
                deadAlive wc, bc
                     
    verb: -> if @verbose then console.log.apply null, arguments
            
module.exports = Score
