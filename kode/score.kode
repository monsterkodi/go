###
 0000000   0000000   0000000   00000000   00000000
000       000       000   000  000   000  000     
0000000   000       000   000  0000000    0000000 
     000  000       000   000  000   000  000     
0000000    0000000   0000000   000   000  00000000
###

{ stoneColor, stone, alpha, ilpha, opponent } = require './util'
{ fs } = require 'kxk'
{ min } = Math
Grid = require './grid'
DeadStones = require '@sabaki/deadstones'

function Score

    @: (a) ->
        
        @grid = new Grid a
        @size = @grid.size
        @captures = black:0 white:0
        
    clone: ->
        
        s = new Score @size
        s.captures = clone @captures
        s.grid.copy @grid 
        s

    #  0000000  000      00000000   0000000   00000000   
    # 000       000      000       000   000  000   000  
    # 000       000      0000000   000000000  0000000    
    # 000       000      000       000   000  000   000  
    #  0000000  0000000  00000000  000   000  000   000  
    
    clear: ->
        
        @captures = black:0 white:0
        @grid.clear @size
        
    #  0000000   0000000   000       0000000   0000000   00000000    0000000   000   000  00000000    0000000  
    # 000       000   000  000      000       000        000   000  000   000  000   000  000   000  000       
    # 000       000000000  000      000       000  0000  0000000    000   000  000   000  00000000   0000000   
    # 000       000   000  000      000       000   000  000   000  000   000  000   000  000             000  
    #  0000000  000   000  0000000   0000000   0000000   000   000   0000000    0000000   000        0000000   
    
    calcGroups: ->
        
        @grps  = []
        @areas = []
        
        allg = @allGroups()
        for s,gl of allg
            for g in gl
                n = @groupNeighbors g
                if s == stone.empty
                    @areas.push 
                        area:  g
                        posl:  g
                        key:   g.join ' '
                        grps:  []
                        color: @areaColor g
                        state: 'neutral'
                        neighbors: n
                else
                    @grps.push
                        stone: s
                        group: g
                        posl:  g
                        areas: []
                        eyes:  []
                        links: []
                        libs:  n.filter((p) => stone.empty == @stoneAt @coord p).length
                        neighbors: n
                        diagonals: @groupDiagonals g, n
                        key:   g.join ' '
                        state: 'unknown'

        # log @groupString.apply @, @grps
        # log @grpsString.apply  @, @grps
        # log @groupString.apply @, @areas
       
    groupIndex: (g) -> @grps.indexOf g
    isLinked: (a,b) -> @groupIndex(b) in a.links
        
    createLink: (a,b) ->
        
        return if @isLinked a,b
        
        ai = @groupIndex a
        bi = @groupIndex b
        
        a.links.push bi if bi not in a.links
        b.links.push ai if ai not in b.links
        
        # log @groupString.apply @, [a,b]
        
    linkGroups: ->
        
        for g in @grps
            for dp in g.diagonals
                if dg = @groupAt dp
                    if dg.stone == g.stone and @groupsShareArea g, dg
                        @createLink g, dg
                        
    groupsShareArea: (a,b) ->
        
        for ai in a.areas
            for bi in b.areas
                return true if ai == bi
        false

    chainIndexForGroup: (g) -> 
        
        return g.chain if g.chain? 
        fi = @grps.indexOf g
        for ch in @chains
            ci = @chains.indexOf ch
            for gi in ch.grps
                return ci if fi == gi        
        -1
                        
    #  0000000   0000000   000       0000000   0000000  000   000   0000000   000  000   000   0000000  
    # 000       000   000  000      000       000       000   000  000   000  000  0000  000  000       
    # 000       000000000  000      000       000       000000000  000000000  000  000 0 000  0000000   
    # 000       000   000  000      000       000       000   000  000   000  000  000  0000       000  
    #  0000000  000   000  0000000   0000000   0000000  000   000  000   000  000  000   000  0000000   
    
    calcChains: ->
        
        @chains = []
        
        for g in @grps
            gi = @groupIndex g
            if valid g.links
                ci = g.chain
                if not ci
                    ci = @chainIndexForGroup g
                    if ci == -1
                        for li in g.links
                            ci = @chainIndexForGroup @grps[li]
                            if ci != -1 ➜ break
                    if ci == -1
                        ci = @chains.length
                        @chains.push grps:[]
                ch = @chains[ci]
                ch.grps.push gi if gi not in ch.grps
                for li in g.links
                    if li not in ch.grps
                        @grps[li].chain = ci
                        ch.grps.push li
                g.chain = ci
            else
                ci = @chains.length
                @chains.push grps:[gi]
                g.chain = ci
        
        for ch in @chains
            for oc in @chains
                if ch != oc
                    for gi in ch.grps
                        if gi in oc.grps
                            if ch.grps.length > oc.grps.length
                                @chains.splice @chains.indexOf(oc), 1
                                break
                            else
                                @chains.splice @chains.indexOf(ch), 1
                                break
                
        # log noon @chains
                        
        for ch in @chains
            ch.areas = []
            ch.posl  = []
            ch.eyes  = []
            ch.stone = @grps[ch.grps[0]].stone
            for gi in ch.grps
                ch.posl = ch.posl.concat @grps[gi].posl
                for ai in @grps[gi].areas
                    ch.areas.push ai if ai not in ch.areas
                for ai in @grps[gi].eyes
                    ch.eyes.push ai if ai not in ch.eyes
                    
            n = @poslNeighbors ch.posl
            ch.neighbors = n
            ch.libs = n.filter((p) => stone.empty == @stoneAt @coord p).length
            if ch.eyes.length > 1
                # ch.alive = true
                @aliveChains [ch]

        # log @chainString.apply @, @chains
        
        @fancySchmanzy()
        
        @deadOrAlive()
        
        battle = []
        for ch in @chains
            if not ch.alive
                # log "chain #{@chains.indexOf ch}" ch
                # log @groupString.apply @, ch.grps.map (gi) => @grps[gi]
                # log @groupString.apply @, ch.areas.map (ai) => @areas[ai]
                # if ch.eyes.length > 0
                    # log 'got one eye'
                    # log @groupString.apply @, ch.eyes.map (ai) => @areas[ai]
                    
                if ch.areas.length == 1
                    battle.push ch.areas[0] if ch.areas[0] not in battle
                    
        for ai in battle
            @areaBattle ai
            
        for ch in @chains
            if not ch.alive and not ch.dead
                @chainBattle ch
                
        log @chainString.apply @, @chains
        
        @deadOrAlive()        

    #  0000000  000   000   0000000   000  000   000  0000000     0000000   000000000  000000000  000      00000000  
    # 000       000   000  000   000  000  0000  000  000   000  000   000     000        000     000      000       
    # 000       000000000  000000000  000  000 0 000  0000000    000000000     000        000     000      0000000   
    # 000       000   000  000   000  000  000  0000  000   000  000   000     000        000     000      000       
    #  0000000  000   000  000   000  000  000   000  0000000    000   000     000        000     0000000  00000000  
    
    chainBattle: (ch) ->

        log "chainBattle #{@chains.indexOf ch}" ch
        # log @chains
        for oc in @chains
            if oc != ch and not oc.dead
                lostAreas = []
                for ai in ch.areas
                    if ai in oc.areas
                        # log "shares are #{ai} with chain #{@chains.indexOf(oc)}"
                        if oc.eyes.length > 1
                            if @chainAreaLibs(ch, ai) <  @chainAreaLibs(oc, ai)
                                log "lost area #{ai}" @chainAreaLibs(ch, ai), @chainAreaLibs(oc, ai)
                                lostAreas.push ai
                log lostAreas, lostAreas.length, ch.areas.length
                if lostAreas.length == ch.areas.length
                    log 'lost all areas!' 
                    @deadChains [ch]
                    return
        
    deadChains: (chains) ->
        
        for ch in chains
            ch.dead = true
            for gi in ch.grps
                log 'dead' @grps[gi].key
                @grps[gi].state = 'dead'
        
    aliveChains: (chains) ->
        
        for ch in chains
            ch.alive = true
            for gi in ch.grps
                # log 'alive' @grps[gi].key
                @grps[gi].state = 'alive'
    
    #  0000000   00000000   00000000   0000000   0000000     0000000   000000000  000000000  000      00000000  
    # 000   000  000   000  000       000   000  000   000  000   000     000        000     000      000       
    # 000000000  0000000    0000000   000000000  0000000    000000000     000        000     000      0000000   
    # 000   000  000   000  000       000   000  000   000  000   000     000        000     000      000       
    # 000   000  000   000  00000000  000   000  0000000    000   000     000        000     0000000  00000000  
    
    areaBattle: (ai) ->
        
        # log "areaBattle" ai
        
        deadAlive = (dead, alive) =>
            
            @deadChains  dead.filter (dc) -> dc.areas.length == 1
            @aliveChains alive
            
        a = @areas[ai]
        chains = @chainsForArea ai
        
        return if chains.length < 2
        
        # log "battle area #{ai}" 
        # log chains
        gs = []
        wc = []
        bc = []
        for ch in chains
            wc.push ch if ch.stone == stone.white
            bc.push ch if ch.stone == stone.black
            for gi in ch.grps
                gs.push @grps[gi] if gi not in gs
                
        # log @groupString.apply @, gs
        
        if wc.length and bc.length
                        
            wc.sort (a,b) => @chainAreaLibs(a,ai) - @chainAreaLibs(b,ai)
            bc.sort (a,b) => @chainAreaLibs(a,ai) - @chainAreaLibs(b,ai)
            
            wl = @chainAreaLibs wc[0],ai
            bl = @chainAreaLibs bc[0],ai
            
            if (wl - bl) > 2
                # log 'white more libs' wl, bl
                deadAlive bc, wc
            else if (bl - wl) > 2
                # log 'black more libs' bl, wl
                deadAlive wc, bc
     
    poslUnion: (a,b) ->
        
        a.filter (ai) -> ai in b

    chainAreaLibs: (ch,ai) -> @poslUnion(ch.neighbors, @areas[ai].posl).length
        
    chainsForArea: (ai) ->
        
        @chains.filter (ch) -> ai in ch.areas
        
    calcAreas: ->
        
        alive = @grps.filter (g) -> g.state == 'alive'
        for ag in alive
            for ai in ag.areas
                challenged = false
                aa = @areas[ai]
                for gi in aa.grps
                    gg = @grps[gi]
                    if gg.state == 'alive' and gg.stone != ag.stone 
                        challenged = true
                if not challenged
                    aa.color = stoneColor[ag.stone][0]
        
    #  0000000   0000000   000       0000000   0000000   0000000   0000000   00000000   00000000  
    # 000       000   000  000      000       000       000       000   000  000   000  000       
    # 000       000000000  000      000       0000000   000       000   000  0000000    0000000   
    # 000       000   000  000      000            000  000       000   000  000   000  000       
    #  0000000  000   000  0000000   0000000  0000000    0000000   0000000   000   000  00000000  
    
    calcScore: ->
        
        # ● calcScore
              
        @calcGroups()
        @linkAreas()
        @linkGroups()
        @calcChains()
        @calcAreas()
                
        dead = @grps.filter (g) -> g.state == 'dead'
                                    
        for g in @grps
            log g.state, g.key
  
        @deadOrAlive()
        
        # log @areaString 1
        # log @deadString 1
            
        # binary = @grid.toBinarray()
        # DeadStones.guess(binary).then (guess) ->
            # log noon guess
        
        # dead = @grps.filter (g) -> g.state == 'dead'
        # eyes = @areas.filter (a) -> a.color in 'wb'
        # log @groupString.apply @, dead.concat eyes
         
        points = @captures
        
        log points
        
        for a in @areas
            if a.color in 'wb'
                points[stoneColor[a.color]] += a.posl.length

        log points
        
        for dg in dead
            for dp in dg.posl
                points[opponent[stoneColor[dg.stone]]] += 2

        log points
        
        if points.white > points.black
            finalScore = 'W+'+(points.white-points.black)
        else
            finalScore = 'B+'+(points.black-points.white)
            
        finalScore

    
    # 00000000   00000000   0000000  000   000  00000000    0000000  000  000   000  00000000  
    # 000   000  000       000       000   000  000   000  000       000  000   000  000       
    # 0000000    0000000   000       000   000  0000000    0000000   000   000 000   0000000   
    # 000   000  000       000       000   000  000   000       000  000     000     000       
    # 000   000  00000000   0000000   0000000   000   000  0000000   000      0      00000000  
    
    calcScoreRecursive: (root) ->
        
        # ● calcScore
              
        @calcGroups()
                
        markDead = (g,r) =>
            
            # log @groupString g
            # log 'dead:' r, g
            
            g.state = 'dead'
            
            for ai in g.areas
                a = @areas[ai]
                for gi in a.grps
                    gg = @grps[gi]
                    if gg.stone != g.stone and gg.state == 'dead'
                        # log 'reanimate' gg.key
                        gg.state = 'undead'
        @linkAreas()
        
        for g in @grps
                        
            continue if g.state == 'dead'
            continue if g.state.startsWith 'alive'
            
            if g.libs == 1
                markDead g, 'single lib'
                continue
            
            if g.eyes.length < 2
                
                if @potentialConnection g
                    g.state = 'alive_potentialConnection'
                    continue
                    
                a = g.eyes.length ? @areas[g.eyes[0]] : @areas[g.areas[0]]
                
                if not a
                    log g
                
                for gi in a.grps
                    o = @grps[gi]
                    if o.stone != g.stone and o.eyes.length > 1
                        if not @potentialGroup g 
                            markDead g, 'no eyes and no potential'
                            break
                          
                continue if g.state == 'dead'

                if g.areas.length == 1 and @deadShape a
                    markDead g, 'dead shape'
                    continue
                    
                continue if g.state.startsWith 'alive'
                        
                if valid(weak = @weakCollection g)
                    for w in weak
                        markDead w, 'weak collection'
                    
                continue if g.state == 'dead'
                        
                if g.areas.length == 2
                    for ai in g.areas
                        if ai not in g.eyes
                            if  not @potentialEye(g, @areas[ai]) and
                                not @suicidalEye(g, @areas[ai])
                                    markDead g, 'no potential and no suicidal 2nd eye'
                
                # if g.state == 'unknown'
                    # log 'no two eyes' g.key, g.state
                                    
            # log g.key, g.state
           
        dead = @grps.filter (g) -> g.state == 'dead'
        
        if valid dead
            # log 'dead:' dead.length
            # log @grps
            
            score = @clone()
            for g in dead
                for p in g.posl
                    score.captures[opponent[g.stone]]++
                    score.grid.set p, ' '
            
            final = score.calcScore @
            
        else
            # log 'no more death:' dead.length
            final = @
                
        if not root
                                        
            for g in @grps
                if g.state == 'unknown'
                    if stone.empty == final.grid.at g.posl[0]
                        log 'late death' g
                        markDead g, 'late death'
                        # g.state = 'dead'
                        
            for a in @areas
                a.color = final.areaAt(a.posl[0]).color

            log @areaString()
                
            # binary = @grid.toBinarray()
            # DeadStones.guess(binary).then (guess) ->
                # log noon guess
            
            # dead = @grps.filter (g) -> g.state == 'dead'
            # eyes = @areas.filter (a) -> a.color in 'wb'
            # log @groupString.apply @, dead.concat eyes
             
            points = copy final.captures
            
            for a in final.areas
                if a.color in 'wb'
                    points[stoneColor[a.color]] += a.posl.length

            if points.white > points.black
                finalScore = 'W+'+(points.white-points.black)
            else
                finalScore = 'B+'+(points.black-points.white)
                
            finalScore

        else
            
            final
            
    #  0000000   00000000   00000000   0000000   
    # 000   000  000   000  000       000   000  
    # 000000000  0000000    0000000   000000000  
    # 000   000  000   000  000       000   000  
    # 000   000  000   000  00000000  000   000  

    linkAreas: ->
        
        for a in @areas
            ai = @areas.indexOf a
            for n in a.neighbors
                if g = @groupAt n
                    gi = @grps.indexOf g
                    if gi not in a.grps
                        a.grps.push gi
                    if ai not in g.areas
                        g.areas.push ai
                    if a.color == stoneColor[g.stone][0]
                        if ai not in g.eyes
                            g.eyes.push ai
    
    areaAt: (p) ->
        
        for a in @areas
            return a if p in a.posl

    groupAt: (p) ->
        
        for g in @grps
            if p in g.posl
                return g
                
    areaColor: (g) ->
        
        cl = g.map (p) => @potentialOwner @coord p
        sl = cl.filter((r) -> r?).join ''
        if '?' in sl
            '?'
        else if not '○●' in sl and not '●○' in sl and sl.length > 0
            c = stoneColor[sl[0]][0]
        else
            '.'
            
    # 0000000    00000000   0000000   0000000     0000000  000   000   0000000   00000000   00000000  
    # 000   000  000       000   000  000   000  000       000   000  000   000  000   000  000       
    # 000   000  0000000   000000000  000   000  0000000   000000000  000000000  00000000   0000000   
    # 000   000  000       000   000  000   000       000  000   000  000   000  000        000       
    # 0000000    00000000  000   000  0000000    0000000   000   000  000   000  000        00000000  
    
    deadShape: (a) ->
        
        if a.posl.length < 6
            
            af = a.posl.filter (p) => '?' != @potentialOwner @coord p
            if af.length < 4 ➜ return true
            cs = @minCoords af.map @coord
            ss = cs.map((c) -> ''+c[0]+c[1]).join ' '
            return ss in [
                '00 01 11 02 12'
                '10 01 11 02 12'
                '00 10 20 11 21'
                '01 10 20 11 21'
                '00 10 01 11 20'
                '00 10 01 11 21'
                '00 10 01 11 02'
                '00 10 01 11 12'
                '00 10 01 11'
                ]
        false
        
    minCoords: (cs) ->
        
        mx = my = Infinity
        for c in cs
            mx = min c[0], mx
            my = min c[1], my
        cs = cs.map (c) -> [c[0]-mx, c[1]-my]
        cs.sort (a,b) -> 
            if a[1] != b[1]
                a[1] - b[1]
            else
                a[0] - b[0]

    # 00000000    0000000   000000000  00000000  000   000  000000000  000   0000000   000      
    # 000   000  000   000     000     000       0000  000     000     000  000   000  000      
    # 00000000   000   000     000     0000000   000 0 000     000     000  000000000  000      
    # 000        000   000     000     000       000  0000     000     000  000   000  000      
    # 000         0000000      000     00000000  000   000     000     000  000   000  0000000  
    
    potentialOwner: (c) ->
        
        if stone.empty == @stoneAt c
            rc = @rayColors c
            p = rc.filter((r) -> r?).join ''
            if '○●' in p or '●○' in p 
                '?'
            else if p.length
                p[0]
                
    potentialGroup: (g) ->
        
        for n in g.neighbors
            if @stoneAt(n) == stone.empty and g.stone == @potentialOwner @coord n
                return true
                        
    potentialConnection: (g) ->
        
        for d in g.diagonals
            if g.stone == @stoneAt d
                for n in @posNeighbors d
                    if n in g.neighbors and stone.empty == @stoneAt n
                        bad = false
                        for ei in g.eyes
                            if n in @areas[ei].posl and @areas[ei].posl.length == 1
                                bad = true
                        for ai in g.areas
                            if n in @areas[ai].posl and @areas[ai].posl.length == 1 # area length > 1?
                                bad = true
                        if not bad
                            return true
        false
        
    potentialEye: (g, a) ->
        
        if a.posl.length < 2 ➜ return false
        if a.posl.length == 2
            cnt = '○':0 '●':0 ' ':0
            for n in a.neighbors
                cnt[@stoneAt n]++
            if cnt['○'] == cnt['●'] ➜ return false
        true

    suicidalEye: (g, a) ->
        
        if a.posl.length > 2 ➜ return false
        opponentGroups = [] 
        opponentSuicides = []
        for gi in a.grps
            if @grps[gi].stone != g.stone
                opponentGroups.push gi
                if @grps[gi].eyes.length < 2 and @grps[gi].libs <= 2 
                    opponentSuicides.push gi

        opponentGroups.length == opponentSuicides.length
        
    # 000   000  00000000   0000000   000   000  
    # 000 0 000  000       000   000  000  000   
    # 000000000  0000000   000000000  0000000    
    # 000   000  000       000   000  000  000   
    # 00     00  00000000  000   000  000   000  
    
    weakEye: (g, a) -> 
        
        a.grps.length > 2
        
    weakCollection: (g) ->

        friends = []
        if 1 <= g.eyes.length <= 2
            for ai in g.areas
                a = @areas[ai]
                for gi in a.grps
                    if @grps[gi].stone == g.stone
                        friends.push @grps[gi] if not @grps[gi] in friends
                        
            if friends.length <= g.areas.length
                friends = []

            if friends.length
                for f in friends
                    if f.eyes.length > 1
                        return []
        friends
        
    # 00000000    0000000   000   000  
    # 000   000  000   000   000 000   
    # 0000000    000000000    00000    
    # 000   000  000   000     000     
    # 000   000  000   000     000     
    
    rayColor: (c, d) ->
        
        n = [c[0]+d[0], c[1]+d[1]]
        s = @stoneAt n
        s == stone.empty ? @rayColor(n, d) : s

    rayColors: (c) ->

        [[1 0] [0 1] [-1 0] [0 -1]].map (r) => @rayColor c, r
            
    # 000      000  0000000    00000000  00000000   000000000  000  00000000   0000000  
    # 000      000  000   000  000       000   000     000     000  000       000       
    # 000      000  0000000    0000000   0000000       000     000  0000000   0000000   
    # 000      000  000   000  000       000   000     000     000  000            000  
    # 0000000  000  0000000    00000000  000   000     000     000  00000000  0000000   
    
    countlib: (p) -> @liberties @coord p
    liberties: (c) ->
        
        if @valid c
            s = @stoneAt c
            if s != stone.empty
                g = @group c
                n = @groupNeighbors g
                n = n.filter (p) => stone.empty == @stoneAt @coord p
                return n.length
        0
        
    # 00000000  00000000   00000000  00000000  0000000     0000000   00     00   0000000  
    # 000       000   000  000       000       000   000  000   000  000   000  000       
    # 000000    0000000    0000000   0000000   000   000  000   000  000000000  0000000   
    # 000       000   000  000       000       000   000  000   000  000 0 000       000  
    # 000       000   000  00000000  00000000  0000000     0000000   000   000  0000000   
    
    free: (color, p) -> @freedoms color, @coord p
    freedoms: (color, c) ->

        l = 0
        for n in @neighbors c
            s = @stoneAt n
            if s == stone.empty then l++
            else if s == stone[color]
                if @liberties(n) > 1
                    l++
        l

    #  0000000   00000000    0000000   000   000  00000000   
    # 000        000   000  000   000  000   000  000   000  
    # 000  0000  0000000    000   000  000   000  00000000   
    # 000   000  000   000  000   000  000   000  000        
    #  0000000   000   000   0000000    0000000   000        

    allGroups: ->

        grps = '○':[] '●':[] ' ':[]
        allp = @allPos()
        while allp.length
            p = allp.pop()
            if s = @stoneAt p
                g = @group @coord p
                for gp in g
                    if 0 <= i = allp.indexOf gp
                        allp.splice i, 1
                grps[s].push g.sort()
        grps
    
    group: (c) ->
        
        s = @stoneAt c
        g = [@pos c]
        f = [@pos c]
        while fp = f.shift()
            for n in @neighbors @coord fp
                if s == @stoneAt n
                    p = @pos n
                    if p not in g
                        g.push p
                        if p not in f then f.push p
        g
        
    # 000   000  00000000  000   0000000   000   000  0000000     0000000   00000000    0000000  
    # 0000  000  000       000  000        000   000  000   000  000   000  000   000  000       
    # 000 0 000  0000000   000  000  0000  000000000  0000000    000   000  0000000    0000000   
    # 000  0000  000       000  000   000  000   000  000   000  000   000  000   000       000  
    # 000   000  00000000  000   0000000   000   000  0000000     0000000   000   000  0000000   
    
    groupNeighbors: (g) ->
        
        gn = []
        for p in g
            for n in @posNeighbors p
                if n not in g and n not in gn
                    gn.push n
        gn

    poslNeighbors: (pl) ->
        
        nl = []
        for p in pl
            for pn in @posNeighbors p
                if pn not in pl and pn not in nl
                    nl.push pn
        nl
        
    posNeighbors: (p) ->
        
        @poslist @neighbors @coord p
        
    neighbors: (c) ->
        
        ns = []
        for [x,y] in [[-1 0] [1 0] [0 -1] [0 1]]
            n = [c[0]+x, c[1]+y]
            if @valid n
                ns.push n
        ns

    # 0000000    000   0000000    0000000    0000000   000   000   0000000   000       0000000  
    # 000   000  000  000   000  000        000   000  0000  000  000   000  000      000       
    # 000   000  000  000000000  000  0000  000   000  000 0 000  000000000  000      0000000   
    # 000   000  000  000   000  000   000  000   000  000  0000  000   000  000           000  
    # 0000000    000  000   000   0000000    0000000   000   000  000   000  0000000  0000000   
    
    groupDiagonals: (g, n) ->
        
        dn = []
        for p in g
            for d in @poslist @diagonals @coord p
                if d not in g and d not in dn and d not in n
                    dn.push d
        dn
        
    diagonals: (c) ->
        
        ns = []
        for [x,y] in [[-1 -1] [1 1] [-1 1] [1 -1]]
            n = [c[0]+x, c[1]+y]
            if @valid n
                ns.push n
        ns
        
    # 000      00000000   0000000    0000000   000      
    # 000      000       000        000   000  000      
    # 000      0000000   000  0000  000000000  000      
    # 000      000       000   000  000   000  000      
    # 0000000  00000000   0000000   000   000  0000000  
    
    legal: (color, c) ->
        
        fr = @freedoms color, c
        mc = @movecaptures color, c
        (fr or mc) and @stoneAt(c) == stone.empty
        
    all_legal: (color) ->
        
        color ?= @nextColor()
        l = []
        for y in 0...@size
            for x in 0...@size
                if @legal color, [x,y]
                    l.push @pos [x,y]
        l
                
    movecaptures: (color, c) ->

        m = stone[color]
        for n in @neighbors c
            s = @stoneAt n
            if s != 'empty' and s != m
                if 1 == @freedoms opponent[color], n
                    return true
        false            
        
    #  0000000   000      000      00000000    0000000    0000000  
    # 000   000  000      000      000   000  000   000  000       
    # 000000000  000      000      00000000   000   000  0000000   
    # 000   000  000      000      000        000   000       000  
    # 000   000  0000000  0000000  000         0000000   0000000   
    
    allPos: ->
        
        p = []
        for y in 0...@size
            for x in 0...@size
                p.push alpha[x]+(@size-y)
        p
        
       
    #  0000000  000000000   0000000   000   000  00000000   0000000
    # 000          000     000   000  0000  000  000       000     
    # 0000000      000     000   000  000 0 000  0000000   0000000 
    #      000     000     000   000  000  0000  000            000
    # 0000000      000      0000000   000   000  00000000  0000000 
    
    allStones: (color) ->
        
        s = stone[color]
        l = []
        for y in 0...@size
            for x in 0...@size
                if s == @stoneAt x,y
                    l.push @pos [x,y]
        l
        
    stoneAt: (x,y) => @grid.at x,y
    valid:   (c)   => 0 <= c[0] < @size and 0 <= c[1] < @size
    coord:   (p)   => [alpha.indexOf(p[0].toUpperCase()), @size-int(p[1..])]
    pos:     (c)   => alpha[c[0]] + (@size-c[1])
    poslist: (cl)  -> cl.map @pos
    
    #  0000000   00000000   00000000   0000000    0000000  000000000  00000000   000  000   000   0000000   
    # 000   000  000   000  000       000   000  000          000     000   000  000  0000  000  000        
    # 000000000  0000000    0000000   000000000  0000000      000     0000000    000  000 0 000  000  0000  
    # 000   000  000   000  000       000   000       000     000     000   000  000  000  0000  000   000  
    # 000   000  000   000  00000000  000   000  0000000      000     000   000  000  000   000   0000000   
    
    areaString: (legend) ->
        
        g = new Grid @grid.toString()
        for a in @areas
            for aa in a.posl
                g.set aa, a.color
        g.toString legend
        
    areaColors: (legend) ->
        
        g = new Grid @grid.toString()
        for a in @areas
            for aa in a.posl
                switch a.color
                    '?' ➜ g.set aa, b6 '?'
                    'w' ➜ g.set aa, w8 '.'
                    'b' ➜ g.set aa, w3 '.'
        for gr in @grps
            for gg in gr.posl
                switch g.at(gg)
                    '○' ➜ g.set gg, w4 '○'
                    '●' ➜ g.set gg, w6 '●'
        g.toAnsi legend

    # 0000000    00000000   0000000   0000000     0000000  000000000  00000000   000  000   000   0000000   
    # 000   000  000       000   000  000   000  000          000     000   000  000  0000  000  000        
    # 000   000  0000000   000000000  000   000  0000000      000     0000000    000  000 0 000  000  0000  
    # 000   000  000       000   000  000   000       000     000     000   000  000  000  0000  000   000  
    # 0000000    00000000  000   000  0000000    0000000      000     000   000  000  000   000   0000000   
    
    deadString: (legend) ->
        
        g = new Grid @grid.toString()
        for gr in @grps
            for gg in gr.posl
                g.set gg, 'X' if gr.state == 'dead'
        g.toString legend

    deadColors: (legend) ->
        
        g = new Grid @grid.toString()
        for gr in @grps
            for gg in gr.posl
                if gr.state == 'dead'
                    g.set gg, r6('X') 
                else
                    g.set gg, w4 g.at gg
            
        g.toAnsi legend
        
    #  0000000   00000000    0000000   000   000  00000000    0000000  000000000  00000000   000  000   000   0000000   
    # 000        000   000  000   000  000   000  000   000  000          000     000   000  000  0000  000  000        
    # 000  0000  0000000    000   000  000   000  00000000   0000000      000     0000000    000  000 0 000  000  0000  
    # 000   000  000   000  000   000  000   000  000             000     000     000   000  000  000  0000  000   000  
    #  0000000   000   000   0000000    0000000   000        0000000      000     000   000  000  000   000   0000000   
    
    rainbow: (idx,c) -> [y5,r5,g2,b8,m3,b4,w4,w8][idx%8](c)
    
    groupString: ->
        
        grid = new Grid @grid.toString()
        for gr in @grps
            if 0 <= (idx = [].slice.call(arguments, 0).indexOf(gr))
                for gg in gr.posl
                    c = arguments[idx].stone == '○' ? '◻' : '◼'
                    grid.set gg, @rainbow idx, c
            else
                for gg in gr.posl
                    grid.set gg, w2 grid.at gg
        for ar in @areas
            if 0 <= (idx = [].slice.call(arguments, 0).indexOf(ar))
                for aa in ar.posl
                    grid.set aa, @rainbow idx, @areas.indexOf ar
        grid.toAnsi 1
        
    grpsString: ->
        
        grid = new Grid @grid.toString()
        for gr in @grps
            if 0 <= (idx = [].slice.call(arguments, 0).indexOf(gr))
                for gg in gr.posl
                    c = @grps.indexOf gr
                    if c > 9 ➜ c = ilpha[c-10]
                    grid.set gg, @rainbow idx, c
        grid.toAnsi 1
        
    chainString: ->

        grid = new Grid @grid.toString()
        for ch in @chains
            if 0 <= (idx = [].slice.call(arguments, 0).indexOf(ch))
                for cp in ch.posl
                    # c = arguments[idx].stone == '○' ? '◻' : '◼'
                    c = @chains.indexOf ch
                    grid.set cp, @rainbow idx, c
        grid.toAnsi 1
        
    fancySchmanzy: ->
        
        as = @groupString.apply(@, @areas).split '\n'
        gs = @grpsString.apply(@,  @grps).split '\n'
        cs = @chainString.apply(@, @chains).split '\n'
        
        pl = @size*2+6
        fs = [w2 rpad(pl, ' areas') + rpad(pl, ' groups') + rpad(pl, ' chains')]
        for i in 0...as.length
            if i == 0 or i == as.length-2
                fs.push as[i]+'   '+gs[i]+'   '+cs[i]
            else if i == as.length-1
                fs.push as[i]+'     '+gs[i]+'     '+cs[i]
            else
                fs.push as[i]+' '+gs[i]+' '+cs[i]
        log fs.join '\n'
        log ''
        
    deadOrAlive: ->
        
        as = @areaColors.apply(@, @areas).split '\n'
        gs = @deadColors(1).split '\n'
        cs = @groupString.apply(@,  @grps.filter((g) -> g.state == 'alive')).split '\n'

        pl = @size*2+6
        fs = [w2 rpad(pl, ' color') + rpad(pl, ' dead') + rpad(pl, ' alive')]
        for i in 0...as.length
            if i == 0 or i == as.length-2
                fs.push as[i]+'   '+gs[i]+'   '+cs[i]
            else if i == as.length-1
                fs.push as[i]+'     '+gs[i]+'     '+cs[i]
            else
                fs.push as[i]+' '+gs[i]+' '+cs[i]
        log fs.join '\n'
        log ''
        
module.exports = Score
