###
 0000000   0000000   0000000   00000000   00000000
000       000       000   000  000   000  000     
0000000   000       000   000  0000000    0000000 
     000  000       000   000  000   000  000     
0000000    0000000   0000000   000   000  00000000
###

{ stoneColor, stone, alpha, opponent } = require './util'
{ noon } = require 'kxk'
{ min } = Math
Grid = require './grid'

function Score

    @: (a) ->
        
        @grid = new Grid a
        @size = @grid.size
        @captures = black:0 white:0
        
    clone: ->
        
        s = new Score @size
        s.captures = copy @captures
        s.grid.copy @grid 
        s

    #  0000000  000      00000000   0000000   00000000   
    # 000       000      000       000   000  000   000  
    # 000       000      0000000   000000000  0000000    
    # 000       000      000       000   000  000   000  
    #  0000000  0000000  00000000  000   000  000   000  
    
    clear: ->
        
        @captures = black:0 white:0
        @grid.clear @size
        
    #  0000000   0000000   000       0000000  
    # 000       000   000  000      000       
    # 000       000000000  000      000       
    # 000       000   000  000      000       
    #  0000000  000   000  0000000   0000000  
    
    calcScore: (root) ->
        
        # ● calcScore
        
        @grps  = []
        @areas = []
        
        for s,gl of @allGroups()
            for g in gl
                n = @groupNeighbors g
                if s == stone.empty
                    @areas.push 
                        area:  g
                        key:   g.join ' '
                        grps:  []
                        color: @areaColor g
                        state: 'neutral'
                        neighbors: n
                else
                    @grps.push
                        stone: s
                        group: g
                        areas: []
                        eyes: []
                        libs:  n.filter((p) => stone.empty == @stoneAt @coord p).length
                        neighbors: n
                        diagonals: @groupDiagonals g, n
                        key:   g.join ' '
                        state: 'unknown'
                        
        dead = false
        score = @clone()
        
        markDead = (g,r) =>
            # log 'dead:' r, g
            
            dead = true
            g.state = 'dead'
            for p in g.group
                score.captures[opponent[g.stone]]++
                score.grid.set p, stone.empty
                
            # log @deadString 1
            # log @areaString 1
            
        if root
            @linkAreas()
            # log noon @grps
            # log noon @areas
            for g in @grps
                if g.eyes.length < 2
                    
                    if @potentialConnection g
                        continue
                        
                    a = g.eyes.length ? @areas[g.eyes[0]] : @areas[g.areas[0]]
                    for gi in a.grps
                        o = @grps[gi]
                        if o.stone != g.stone and o.eyes.length > 1
                            if not @potentialGroup g 
                                markDead g, 'dead no eyes and no potential'
                                break
                                
                    if not dead 
                        if g.areas.length == 1 and @deadShape a
                            markDead g, 'dead shape'
                            
                    if not dead
                        canMakeEye = false
                        for ai in g.areas
                            if not @deadShape @areas[ai]
                                canMakeEye = true
                                break
                                
                        if not canMakeEye
                            if g.areas.length == 2
                                for ai in g.areas
                                    if ai not in g.eyes
                                        if not @potentialEye g, @areas[ai]
                                            markDead g, 'no potential 2nd eye'
            if dead
                final = score.calcScore @
                
        if not root
                    
            for g in @grps
                if g.libs == 1
                    markDead g
                    
            final = score.calcScore @
                        
            for a in final.areas
                if a.color != '.'
                    final.captures[stoneColor[a.color]] += a.area.length
                    
            for g in @grps
                if g.state == 'unknown'
                    if stone.empty == final.grid.at g.group[0]
                        g.state = 'dead'
                        
            for a in @areas
                a.color = final.areaAt(a.area[0]).color
                    
            if final.captures.white > final.captures.black
                finalScore = 'W+'+(final.captures.white-final.captures.black)
            else
                finalScore = 'B+'+(final.captures.black-final.captures.white)
                
            finalScore
                
        else if dead
            final
        else
            @
            
    #  0000000   00000000   00000000   0000000   
    # 000   000  000   000  000       000   000  
    # 000000000  0000000    0000000   000000000  
    # 000   000  000   000  000       000   000  
    # 000   000  000   000  00000000  000   000  

    linkAreas: ->
        
        for a in @areas
            ai = @areas.indexOf a
            for n in a.neighbors
                if g = @groupAt n
                    gi = @grps.indexOf g
                    if gi not in a.grps
                        a.grps.push gi
                    if ai not in g.areas
                        g.areas.push ai
                    if a.color == stoneColor[g.stone][0]
                        if ai not in g.eyes
                            g.eyes.push ai
    
    areaAt: (p) ->
        
        for g in @areas
            if p in g.area
                return g

    groupAt: (p) ->
        
        for g in @grps
            if p in g.group
                return g
                
    areaColor: (g) ->
        
        cl = g.map (p) => @potentialOwner @coord p
        sl = cl.filter((r) -> r?).join ''
        if '?' in sl
            '?'
        else if not '○●' in sl and not '●○' in sl and sl.length > 0
            c = stoneColor[sl[0]][0]
        else
            '.'
            
    # 0000000    00000000   0000000   0000000     0000000  000   000   0000000   00000000   00000000  
    # 000   000  000       000   000  000   000  000       000   000  000   000  000   000  000       
    # 000   000  0000000   000000000  000   000  0000000   000000000  000000000  00000000   0000000   
    # 000   000  000       000   000  000   000       000  000   000  000   000  000        000       
    # 0000000    00000000  000   000  0000000    0000000   000   000  000   000  000        00000000  
    
    deadShape: (a) ->
        
        if a.area.length < 6
            
            af = a.area.filter (p) => '?' != @potentialOwner @coord p
            if af.length < 4 ➜ return true
            cs = @minCoords af.map @coord
            ss = cs.map((c) -> ''+c[0]+c[1]).join ' '
            return ss in [
                '00 01 11 02 12'
                '10 01 11 02 12'
                '00 10 20 11 21'
                '01 10 20 11 21'
                '00 10 01 11 20'
                '00 10 01 11 21'
                '00 10 01 11 02'
                '00 10 01 11 12'
                '00 10 01 11'
                ]
        false
        
    minCoords: (cs) ->
        
        mx = my = Infinity
        for c in cs
            mx = min c[0], mx
            my = min c[1], my
        cs = cs.map (c) -> [c[0]-mx, c[1]-my]
        cs.sort (a,b) -> 
            if a[1] != b[1]
                a[1] - b[1]
            else
                a[0] - b[0]

    # 00000000    0000000   000000000  00000000  000   000  000000000  000   0000000   000      
    # 000   000  000   000     000     000       0000  000     000     000  000   000  000      
    # 00000000   000   000     000     0000000   000 0 000     000     000  000000000  000      
    # 000        000   000     000     000       000  0000     000     000  000   000  000      
    # 000         0000000      000     00000000  000   000     000     000  000   000  0000000  
    
    potentialOwner: (c) ->
        
        if stone.empty == @stoneAt c
            rc = @rayColors c
            p = rc.filter((r) -> r?).join ''
            if '○●' in p or '●○' in p 
                '?'
            else if p.length
                p[0]
                
    potentialGroup: (g) ->
        
        for n in g.neighbors
            if @stoneAt(n) == stone.empty and g.stone == @potentialOwner @coord n
                return true
                
    potentialEye: (g, a) ->
        
        if a.area.length < 2 ➜ return false
        if a.area.length == 2
            cnt = '○':0 '●':0 ' ':0
            for n in a.neighbors
                cnt[@stoneAt n]++
            if cnt['○'] == cnt['●'] ➜ return false
        true
        
    potentialConnection: (g) ->
        
        for d in g.diagonals
            if g.stone == @stoneAt d
                for n in @posNeighbors d
                    if n in g.neighbors and stone.empty == @stoneAt n
                        return true
        false
        
    # 00000000    0000000   000   000  
    # 000   000  000   000   000 000   
    # 0000000    000000000    00000    
    # 000   000  000   000     000     
    # 000   000  000   000     000     
    
    rayColor: (c, d) ->
        
        n = [c[0]+d[0], c[1]+d[1]]
        s = @stoneAt n
        s == stone.empty ? @rayColor(n, d) : s

    rayColors: (c) ->

        [[1 0] [0 1] [-1 0] [0 -1]].map (r) => @rayColor c, r
            
    # 000      000  0000000    00000000  00000000   000000000  000  00000000   0000000  
    # 000      000  000   000  000       000   000     000     000  000       000       
    # 000      000  0000000    0000000   0000000       000     000  0000000   0000000   
    # 000      000  000   000  000       000   000     000     000  000            000  
    # 0000000  000  0000000    00000000  000   000     000     000  00000000  0000000   
    
    countlib: (p) -> @liberties @coord p
    liberties: (c) ->
        
        if @valid c
            s = @stoneAt c
            if s != stone.empty
                g = @group c
                n = @groupNeighbors g
                n = n.filter (p) => stone.empty == @stoneAt @coord p
                return n.length
        0
        
    # 00000000  00000000   00000000  00000000  0000000     0000000   00     00   0000000  
    # 000       000   000  000       000       000   000  000   000  000   000  000       
    # 000000    0000000    0000000   0000000   000   000  000   000  000000000  0000000   
    # 000       000   000  000       000       000   000  000   000  000 0 000       000  
    # 000       000   000  00000000  00000000  0000000     0000000   000   000  0000000   
    
    free: (color, p) -> @freedoms color, @coord p
    freedoms: (color, c) ->

        l = 0
        for n in @neighbors c
            s = @stoneAt n
            if s == stone.empty then l++
            else if s == stone[color]
                if @liberties(n) > 1
                    l++
        l

    #  0000000   00000000    0000000   000   000  00000000   
    # 000        000   000  000   000  000   000  000   000  
    # 000  0000  0000000    000   000  000   000  00000000   
    # 000   000  000   000  000   000  000   000  000        
    #  0000000   000   000   0000000    0000000   000        

    allGroups: ->

        grps = '○':[] '●':[] ' ':[]
        allp = @allPos()
        while allp.length
            p = allp.pop()
            s = @stoneAt p
            g = @group @coord p
            for gp in g
                if 0 <= i = allp.indexOf gp
                    allp.splice i, 1
            grps[s].push g.sort()
        grps
    
    group: (c) ->
        
        s = @stoneAt c
        g = [@pos c]
        f = [@pos c]
        while fp = f.shift()
            for n in @neighbors @coord fp
                if s == @stoneAt n
                    p = @pos n
                    if p not in g
                        g.push p
                        if p not in f then f.push p
        g
        
    # 000   000  00000000  000   0000000   000   000  0000000     0000000   00000000    0000000  
    # 0000  000  000       000  000        000   000  000   000  000   000  000   000  000       
    # 000 0 000  0000000   000  000  0000  000000000  0000000    000   000  0000000    0000000   
    # 000  0000  000       000  000   000  000   000  000   000  000   000  000   000       000  
    # 000   000  00000000  000   0000000   000   000  0000000     0000000   000   000  0000000   
    
    groupNeighbors: (g) ->
        
        gn = []
        for p in g
            for n in @posNeighbors p
                if n not in g and n not in gn
                    gn.push n
        gn
    
    posNeighbors: (p) ->
        
        @poslist @neighbors @coord p
        
    neighbors: (c) ->
        
        ns = []
        for [x,y] in [[-1 0] [1 0] [0 -1] [0 1]]
            n = [c[0]+x, c[1]+y]
            if @valid n
                ns.push n
        ns

    # 0000000    000   0000000    0000000    0000000   000   000   0000000   000       0000000  
    # 000   000  000  000   000  000        000   000  0000  000  000   000  000      000       
    # 000   000  000  000000000  000  0000  000   000  000 0 000  000000000  000      0000000   
    # 000   000  000  000   000  000   000  000   000  000  0000  000   000  000           000  
    # 0000000    000  000   000   0000000    0000000   000   000  000   000  0000000  0000000   
    
    groupDiagonals: (g, n) ->
        
        dn = []
        for p in g
            for d in @poslist @diagonals @coord p
                if d not in g and d not in dn and d not in n
                    dn.push d
        dn
        
    diagonals: (c) ->
        
        ns = []
        for [x,y] in [[-1 -1] [1 1] [-1 1] [1 -1]]
            n = [c[0]+x, c[1]+y]
            if @valid n
                ns.push n
        ns
        
    # 000      00000000   0000000    0000000   000      
    # 000      000       000        000   000  000      
    # 000      0000000   000  0000  000000000  000      
    # 000      000       000   000  000   000  000      
    # 0000000  00000000   0000000   000   000  0000000  
    
    legal: (color, c) ->
        
        fr = @freedoms color, c
        mc = @movecaptures color, c
        @stoneAt(c) == stone.empty and (fr or mc)
        
    all_legal: (color) ->
        
        color ?= @nextColor()
        l = []
        for y in 0...@size
            for x in 0...@size
                if @legal color, [x,y]
                    l.push @pos [x,y]
        l
                
    movecaptures: (color, c) ->

        m = stone[color]
        for n in @neighbors c
            s = @stoneAt n
            if s != 'empty' and s != m
                if 1 == @freedoms opponent[color], n
                    return true
        false            
        
    #  0000000   000      000      00000000    0000000    0000000  
    # 000   000  000      000      000   000  000   000  000       
    # 000000000  000      000      00000000   000   000  0000000   
    # 000   000  000      000      000        000   000       000  
    # 000   000  0000000  0000000  000         0000000   0000000   
    
    allPos: ->
        
        p = []
        for y in 0...@size
            for x in 0...@size
                p.push alpha[x]+(@size-y)
        p
        
       
    #  0000000  000000000   0000000   000   000  00000000   0000000
    # 000          000     000   000  0000  000  000       000     
    # 0000000      000     000   000  000 0 000  0000000   0000000 
    #      000     000     000   000  000  0000  000            000
    # 0000000      000      0000000   000   000  00000000  0000000 
    
    allStones: (color) ->
        
        s = stone[color]
        l = []
        for y in 0...@size
            for x in 0...@size
                if s == @stoneAt x,y
                    l.push @pos [x,y]
        l
        
    stoneAt: (x,y) => @grid.at x,y
    valid:   (c)   => 0 <= c[0] < @size and 0 <= c[1] < @size
    coord:   (p)   => [alpha.indexOf(p[0].toUpperCase()), @size-int(p[1..])]
    pos:     (c)   => alpha[c[0]] + (@size-c[1])
    poslist: (cl)  -> cl.map @pos
    
    #  0000000   00000000   00000000   0000000    0000000  000000000  00000000   000  000   000   0000000   
    # 000   000  000   000  000       000   000  000          000     000   000  000  0000  000  000        
    # 000000000  0000000    0000000   000000000  0000000      000     0000000    000  000 0 000  000  0000  
    # 000   000  000   000  000       000   000       000     000     000   000  000  000  0000  000   000  
    # 000   000  000   000  00000000  000   000  0000000      000     000   000  000  000   000   0000000   
    
    areaString: (legend) ->
        
        g = new Grid @grid.toString()
        for a in @areas
            for aa in a.area
                g.set aa, a.color
        g.toString legend

    # 0000000    00000000   0000000   0000000     0000000  000000000  00000000   000  000   000   0000000   
    # 000   000  000       000   000  000   000  000          000     000   000  000  0000  000  000        
    # 000   000  0000000   000000000  000   000  0000000      000     0000000    000  000 0 000  000  0000  
    # 000   000  000       000   000  000   000       000     000     000   000  000  000  0000  000   000  
    # 0000000    00000000  000   000  0000000    0000000      000     000   000  000  000   000   0000000   
    
    deadString: (legend) ->
        
        g = new Grid @grid.toString()
        for gr in @grps
            for gg in gr.group
                g.set gg, 'X' if gr.state == 'dead'
        g.toString legend
        
module.exports = Score
