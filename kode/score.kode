###
 0000000   0000000   0000000   00000000   00000000
000       000       000   000  000   000  000     
0000000   000       000   000  0000000    0000000 
     000  000       000   000  000   000  000     
0000000    0000000   0000000   000   000  00000000
###

{ stoneColor, stone, alpha } = require './util'
Grid = require './grid'

function Score

    #  0000000   0000000   0000000   00000000   00000000  
    # 000       000       000   000  000   000  000       
    # 0000000   000       000   000  0000000    0000000   
    #      000  000       000   000  000   000  000       
    # 0000000    0000000   0000000   000   000  00000000  
    
    calcScore: ->
        
        # log('%c score' 'font-size: 24px; color:red;')
        gr = new Grid @size
        for s,gl of @allGroups()
            for g in gl
                t = s
                if s == stone.empty
                    t = @areaColor g
                # log t, g.join ' '
                for p in g
                    gr.set p, t
        # log gr.grid
        gr

    # 000      000  0000000    00000000  00000000   000000000  000  00000000   0000000  
    # 000      000  000   000  000       000   000     000     000  000       000       
    # 000      000  0000000    0000000   0000000       000     000  0000000   0000000   
    # 000      000  000   000  000       000   000     000     000  000            000  
    # 0000000  000  0000000    00000000  000   000     000     000  00000000  0000000   
    
    countlib: (p) -> @liberties @coord p
    liberties: (c) ->
        if @valid c
            s = @stoneAt c
            if s != stone.empty
                g = @group c
                n = @group_neighbors g
                n = n.filter (p) => stone.empty == @stoneAt @coord p
                return n.length
        0
        
    # 00000000  00000000   00000000  00000000  0000000     0000000   00     00   0000000  
    # 000       000   000  000       000       000   000  000   000  000   000  000       
    # 000000    0000000    0000000   0000000   000   000  000   000  000000000  0000000   
    # 000       000   000  000       000       000   000  000   000  000 0 000       000  
    # 000       000   000  00000000  00000000  0000000     0000000   000   000  0000000   
    
    free: (color, p) -> @freedoms color, @coord p
    freedoms: (color, c) ->

        l = 0
        for n in @neighbors c
            s = @stoneAt n
            if s == stone.empty then l++
            else if s == stone[color]
                if @liberties(n) > 1
                    l++
        l

    #  0000000   00000000    0000000   000   000  00000000   
    # 000        000   000  000   000  000   000  000   000  
    # 000  0000  0000000    000   000  000   000  00000000   
    # 000   000  000   000  000   000  000   000  000        
    #  0000000   000   000   0000000    0000000   000        

    allGroups: ->

        grps = '○':[] '●':[] ' ':[]
        allp = @allPos()
        while allp.length
            p = allp.pop()
            s = @stoneAt p
            g = @group @coord p
            for gp in g
                if 0 <= i = allp.indexOf gp
                    allp.splice i, 1
            grps[s].push g.sort()
        grps
    
    group: (c) ->
        
        s = @stoneAt c
        g = [@pos c]
        f = [@pos c]
        while fp = f.shift()
            for n in @neighbors @coord fp
                if s == @stoneAt n
                    p = @pos n
                    if p not in g
                        g.push p
                        if p not in f then f.push p
        g
        
    # 000   000  00000000  000   0000000   000   000  0000000     0000000   00000000    0000000  
    # 0000  000  000       000  000        000   000  000   000  000   000  000   000  000       
    # 000 0 000  0000000   000  000  0000  000000000  0000000    000   000  0000000    0000000   
    # 000  0000  000       000  000   000  000   000  000   000  000   000  000   000       000  
    # 000   000  00000000  000   0000000   000   000  0000000     0000000   000   000  0000000   
    
    group_neighbors: (g) ->
        
        gn = []
        for p in g
            for n in @poslist @neighbors @coord p
                if n not in g and n not in gn
                    gn.push n
        gn
        
        
    neighbors: (c) ->
        ns = []
        for [x,y] in [[-1 0] [1 0] [0 -1] [0 1]]
            n = [c[0]+x, c[1]+y]
            if @valid n
                ns.push n
        ns
            
    #  0000000   00000000   00000000   0000000   
    # 000   000  000   000  000       000   000  
    # 000000000  0000000    0000000   000000000  
    # 000   000  000   000  000       000   000  
    # 000   000  000   000  00000000  000   000  
    
    areaColor: (g) ->
        
        cl = g.map (p) => @potentialOwner @coord p
        sl = cl.filter((r) -> r?).join ''
        if not '○●' in sl and not '●○' in sl and sl.length > 0
            stoneColor(sl[0])[0]
        else
            '.'
            
    #  0000000   000   000  000   000  00000000  00000000   
    # 000   000  000 0 000  0000  000  000       000   000  
    # 000   000  000000000  000 0 000  0000000   0000000    
    # 000   000  000   000  000  0000  000       000   000  
    #  0000000   00     00  000   000  00000000  000   000  
    
    potentialOwner: (c) ->
        if stone.empty == @stoneAt c
            rc = @rayColors c
            p = rc.filter((r) -> r?).join ''
            if not '○●' in p and not '●○' in p and p.length > 0
                p[0]
        
    # 00000000    0000000   000   000  
    # 000   000  000   000   000 000   
    # 0000000    000000000    00000    
    # 000   000  000   000     000     
    # 000   000  000   000     000     
    
    rayColor: (c, d) ->
        n = [c[0]+d[0], c[1]+d[1]]
        s = @stoneAt n
        s == stone.empty ? @rayColor(n, d) : s

    rayColors: (c) ->

        [[1 0] [0 1] [-1 0] [0 -1]].map (r) => @rayColor c, r
                                  
    #  0000000   000      000      00000000    0000000    0000000  
    # 000   000  000      000      000   000  000   000  000       
    # 000000000  000      000      00000000   000   000  0000000   
    # 000   000  000      000      000        000   000       000  
    # 000   000  0000000  0000000  000         0000000   0000000   
    
    allPos: ->
        p = []
        for y in 0...@size
            for x in 0...@size
                p.push alpha[x]+(@size-y)
        p
                                        
module.exports = Score
