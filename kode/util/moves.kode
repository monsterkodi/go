###
00     00   0000000   000   000  00000000   0000000
000   000  000   000  000   000  000       000     
000000000  000   000   000 000   0000000   0000000 
000 0 000  000   000     000     000            000
000   000   0000000       0      00000000  0000000 
###

{ stoneColor } = require './util'

function Move

    @: (@pos, @color, @p, @captures=[]) ->
        # log 'move with captures' @pos, @color, @p, @captures if valid @captures

function Moves

    @: -> 
        @m = []
        @p = [0 0]

    num: -> @m.length
    pop: -> 
        
        m = @m.pop()
        @p = @num() ? copy(@last().p) : [0 0]
        m
        
    clear: -> 
        
        @m = [] 
        @p = [0 0] 
        delete @ended
            
    add: (pos,color,captures)  ->
        c = @color color
        @p[(c == 'black') ? 0 : 1] += captures.length if valid captures
        @m.push new Move pos, c, copy(@p), captures
        switch pos
            'pass'   ➜ @ended = @doublePass()
            'resign' ➜ @ended = true
                     ➜ @ended = false

    history:    -> @m.map (m) -> 
                    if m.p[0] or m.p[1]
                        m.pos + ' ' + m.p[0] + ' ' + m.p[1] + (m.captures.length ? (' ' + m.captures.join ' ') : '')
                    else
                        m.pos
    start:      -> @m.length == 0
    color: (c)  -> c ? stoneColor[c] : @nextColor()
    lastColor:  -> @m.length ? ['white''black'][@m.length%2] : 'start'
    nextColor:  -> ['black''white'][@m.length%2]
    lastIsPass: -> @last()?.pos == 'pass'
    singlePass: -> @last()?.pos == 'pass' and @m[-2]?.pos != 'pass'
    doublePass: -> @last()?.pos == 'pass' == @m[-2]?.pos
    resigned:   -> @last()?.pos == 'resign'
    last:       -> @m[@m.length-1]
    end:        -> @ended ? false
                     
module.exports = Moves
