###
00000000   00000000   000  000   000  000000000
000   000  000   000  000  0000  000     000   
00000000   0000000    000  000 0 000     000   
000        000   000  000  000  0000     000   
000        000   000  000  000   000     000   
###

Grid = require './grid'
{ short, stone } = require './util'

function Print

    #  0000000   00000000   00000000   0000000    0000000
    # 000   000  000   000  000       000   000  000     
    # 000000000  0000000    0000000   000000000  0000000 
    # 000   000  000   000  000       000   000       000
    # 000   000  000   000  00000000  000   000  0000000 
    
    areaString: (legend) ->
        
        g = new Grid @grid.toString()
        for a in @areas
            for aa in a.posl
                g.set aa, a.color
        g.toString legend
        
    areaColors: (legend) ->
        
        g = new Grid @grid.toString()
        for a in @areas
            for aa in a.posl
                switch a.color
                    '?' ➜ g.set aa, b6 '?'
                    'w' ➜ g.set aa, w8 '.'
                    'b' ➜ g.set aa, w3 '.'
        for gr in @grps
            for gg in gr.posl
                switch g.at(gg)
                    '○' ➜ g.set gg, w4 '○'
                    '●' ➜ g.set gg, w6 '●'
        g.toAnsi legend

    # 0000000    00000000   0000000   0000000  
    # 000   000  000       000   000  000   000
    # 000   000  0000000   000000000  000   000
    # 000   000  000       000   000  000   000
    # 0000000    00000000  000   000  0000000  
    
    deadString: (legend) ->
        
        g = new Grid @grid.toString()
        for gr in @grps
            for gg in gr.posl
                g.set gg, 'X' if gr.state == 'dead'
        g.toString legend

    deadColors: (legend) ->
        
        g = new Grid @grid.toString()
        for gr in @grps
            for gg in gr.posl
                if gr.state == 'dead'
                    g.set gg, gr.stone == stone.white ? r6('X') : b6('X')
                else
                    g.set gg, w4 g.at gg
            
        g.toAnsi legend
        
    #  0000000   00000000    0000000   000   000  00000000    0000000
    # 000        000   000  000   000  000   000  000   000  000     
    # 000  0000  0000000    000   000  000   000  00000000   0000000 
    # 000   000  000   000  000   000  000   000  000             000
    #  0000000   000   000   0000000    0000000   000        0000000 
        
    groupString: ->
        
        grid = new Grid @grid.toString()
        for gr in @grps
            if 0 <= (idx = [].slice.call(arguments, 0).indexOf(gr))
                for gg in gr.posl
                    c = arguments[idx].stone == '○' ? '◻' : '◼'
                    grid.set gg, @rainbow idx, c
            else
                for gg in gr.posl
                    grid.set gg, w2 grid.at gg
        for ar in @areas
            if 0 <= (idx = [].slice.call(arguments, 0).indexOf(ar))
                for aa in ar.posl
                    c = @areas.indexOf ar
                    grid.set aa, @rainbow idx, short[c]
        grid.toAnsi 1
        
    grpsString: ->
        
        grid = new Grid @grid.toString()
        for gr in @grps
            if 0 <= (idx = [].slice.call(arguments, 0).indexOf(gr))
                for gg in gr.posl
                    c = @grps.indexOf gr
                    grid.set gg, @rainbow idx, short[c]
        grid.toAnsi 1
        
    #  0000000  000   000   0000000   000  000   000   0000000  
    # 000       000   000  000   000  000  0000  000  000       
    # 000       000000000  000000000  000  000 0 000  0000000   
    # 000       000   000  000   000  000  000  0000       000  
    #  0000000  000   000  000   000  000  000   000  0000000   
    
    chainString: ->

        grid = new Grid @grid.toString()
        for ch in @chains
            if 0 <= (idx = [].slice.call(arguments, 0).indexOf(ch))
                for cp in ch.posl
                    # c = arguments[idx].stone == '○' ? '◻' : '◼'
                    c = @chains.indexOf ch
                    grid.set cp, @rainbow idx, short[c]
        grid.toAnsi 1
        
    # 00000000   0000000   000   000   0000000  000   000  
    # 000       000   000  0000  000  000        000 000   
    # 000000    000000000  000 0 000  000         00000    
    # 000       000   000  000  0000  000          000     
    # 000       000   000  000   000   0000000     000     
    
    fancySchmanzy: ->

        bd = @grid.toString(1).split '\n'
        ml = bd[1].length        
        as = @groupString.apply(@, @areas).split '\n'
        gs = @grpsString.apply(@,  @grps).split '\n'
        cs = @chainString.apply(@, @chains).split '\n'
        
        pl = @size*2+6
        fs = [w2 rpad(pl, ' areas') + rpad(pl, ' groups') + rpad(pl, ' chains')]
        for i in 0...as.length
            spc = lpad ml-bd[i].length, ''
            fs.push as[i]+spc+gs[i]+spc+cs[i]
        log fs.join '\n'
        log ''
        
    # 0000000    00000000   0000000   0000000    
    # 000   000  000       000   000  000   000  
    # 000   000  0000000   000000000  000   000  
    # 000   000  000       000   000  000   000  
    # 0000000    00000000  000   000  0000000    
    
    deadOrAlive: ->
        
        bd = @grid.toString(1).split '\n'
        ml = bd[1].length
        as = @areaColors.apply(@, @areas).split '\n'
        gs = @deadColors(1).split '\n'
        cs = @groupString.apply(@,  @grps.filter((g) -> g.state == 'alive')).split '\n'

        pl = @size*2+6
        fs = [w2 rpad(pl, ' color') + rpad(pl, ' dead') + rpad(pl, ' alive')]
        for i in 0...as.length
            spc = lpad ml-bd[i].length, ''
            fs.push as[i]+spc+gs[i]+spc+cs[i]
        log fs.join '\n'
        log ''

    rainbow: (idx,c) -> [y5,r5,g2,b8,m3,b4,w4,w8][idx%8](c)
    
module.exports = Print
